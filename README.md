## The repository

Mulbase/Mulgen is a front-end library for DGraph. It includes static (mostly) code generation based on the same schema supplied to the database so no need to keep the client structs separate.
It ensures json tags are set in sync with the schema and ensures compatibility with the database. 

Note that this code does not, as of right now, use vendor/modules. This will be changed eventually. There are no guarantees whatsoever about this library right now.

This is only tested against the beta DGraph graphql api. Altering the schema using GraphQL only works on this docker image/branch.

It generates definitions from GraphQL but right now it queries the database using regular GraphQL+-.

## Mulgen

Mulgen is the library for generating structs and common definitions.

The code is mostly hacked together to get the functionality. Once I've decided exactly how it will generate models the code will
be written to be easier to understand and deal with. 

## Mulbase

Mulbase represents the regular code for interacting with the database through the DNode interface which is satisfied by all generated classes. It includes GeneratedQuery's, StaticQuery's(simple string queries), SingleMutations as well as MultipleMutations. These all exist inside Txn objects with simple commit-now calls also available straight in the *DB class.
Also, arbitrary interfaces can be mutated as well, for instance a map\[string\]interface{} using the Mapper wrapper over it. 
Most features are wrapped around an interface and by implementing methods you can modify how the package sends data to the DB. This level of control
is crucial for a graph database as, for instance, mutating a struct with an edge you can accidentally overwrite values in its relation.

The query interface is a lot more done than the mutation interface. 

Right now it does not really have proper testing. What needs to be added is a method to autostart the GraphQL DGraph api, alter the schema, etc. 

It supports(TODO) DGraph language tags by following the schema and supplying them in the generated query as needed.

An underlying point about many functions like SaveScalars is it does not run immediately. It returns a query object as you might want to extend the query. After that you simply
execute it inside a transaction object or the DB directly.

## Notes about GraphQL

The GraphQL Non-null(! operator) defines whether or not scalar values are autogenerated. For non-scalar values it doesn't really matter right now. 

## Graphql-Go

This is derived from https://github.com/graph-gophers/graphql-go. A lot of code has been removed that
was not necessary since primarily the parsing was needed and not the actual GraphQL elements. (It does not represent a GraphQL server)
The foremost change was making the schema and its objects public for code generation.

## Getting started

Running mulbase/gen/parse/main.go with input/output flags generates the model files, mulgen.go and gen.go. 
These are used with mulbase. Create a new DB object using mulbase.Init() and set the schema from the global fields
generated. You can then use this to query.

## TODOS

Language tags are soon to be added properly, I'm not sure how they work with DGraph GraphQL. 
Proper testing. 
Finalize the API.
Comment.
Clean up the gen directory. Code is messy.