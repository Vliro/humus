package gen

//Code generated by mulgen. DO NOT EDIT (i mean, it will all be lost in the void)

import (
	"context"
	"github.com/Vliro/mulbase"
	"time"
)

var _ context.Context
var _ time.Time
var _ mulbase.Fields

//Created from a GraphQL interface.
type Post struct {
	//This line declares basic properties for a database node.
	mulbase.Node
	Text          string     `json:"Post.text,omitempty"`
	DatePublished *time.Time `json:"Post.datePublished,omitempty"`
	From          *User      `json:"Post.from,omitempty"`
	Comments      []Comment  `json:"~Comment.commentsOn,omitempty"`
}

var PostFields mulbase.FieldList = []mulbase.Field{MakeField("Post.text", 0|mulbase.MetaLang), MakeField("Post.datePublished", 0), MakeField("Post.from", 0|mulbase.MetaObject), MakeField("~Comment.commentsOn", 0|mulbase.MetaObject|mulbase.MetaList|mulbase.MetaReverse)}

//Generating constant field values.
const (
	PostTextField          mulbase.Predicate = "Post.text"
	PostDatePublishedField mulbase.Predicate = "Post.datePublished"
	PostFromField          mulbase.Predicate = "Post.from"
	PostCommentsField      mulbase.Predicate = "~Comment.commentsOn"
)

//SaveValues saves the node values that
//do not contain any references to other objects.
func (r *Post) SaveValues(ctx context.Context, txn *mulbase.Txn) error {
	mut := mulbase.CreateMutation(r.Values(), mulbase.MutateSet)
	_, err := txn.Mutate(ctx, mut)
	return err
}
func (r *Post) GetType() []string {
	if r.Type == nil {
		r.SetType()
	}
	return r.Type
}

func (r *Post) Facets() []string {
	return nil
}

//Fields returns all Scalar fields for this value.
func (r *Post) Fields() mulbase.FieldList {
	return PostFields
}

//Sets the types. This DOES NOT include interfaces!
//as they are set in dgraph already.
func (r *Post) SetType() {
	r.Type = []string{
		"Post",
	}
}

//Values returns all the scalar values for this node.
func (r *Post) Values() mulbase.DNode {
	var m PostScalars
	m.Text = r.Text
	m.DatePublished = r.DatePublished
	r.SetType()
	m.Node = r.Node
	return &m
}

//Values returns all the scalar values for this node.
//Note that this completely ignores any omitempty tags so use with care.
func (r *Post) MapValues() mulbase.Mapper {
	var m = make(map[string]interface{})
	m["Post.text"] = r.Text
	m["Post.datePublished"] = r.DatePublished
	if r.Uid != "" {
		m["uid"] = r.Uid
	}
	r.SetType()
	m["dgraph.type"] = r.Type
	return m
}

//PostScalars is simply to avoid a map[string]interface{}
//It is a mirror of the previous struct with all scalar values.
type PostScalars struct {
	mulbase.Node
	Text          string     `json:"Post.text,omitempty"`
	DatePublished *time.Time `json:"Post.datePublished,omitempty"`
}

func (s *PostScalars) Values() mulbase.DNode {
	return s
}

func (s *PostScalars) MapValues() mulbase.Mapper {
	panic("PostScalars called, use the original one instead")
}

func (s *PostScalars) Fields() mulbase.FieldList {
	return PostFields
}

//End of model.template
type Question struct {
	//This line declares basic properties for a database node.
	mulbase.Node
	//List of interfaces implemented.
	Post
	//Regular fields
}

var QuestionFields mulbase.FieldList = []mulbase.Field{MakeField("Post.text", 0|mulbase.MetaLang), MakeField("Post.datePublished", 0), MakeField("Post.from", 0|mulbase.MetaObject), MakeField("~Comment.commentsOn", 0|mulbase.MetaObject|mulbase.MetaList|mulbase.MetaReverse)}

//Generating constant field values.
const (
	QuestionTextField          mulbase.Predicate = "Post.text"
	QuestionDatePublishedField mulbase.Predicate = "Post.datePublished"
	QuestionFromField          mulbase.Predicate = "Post.from"
	QuestionCommentsField      mulbase.Predicate = "~Comment.commentsOn"
)

//SaveValues saves the node values that
//do not contain any references to other objects.
func (r *Question) SaveValues(ctx context.Context, txn *mulbase.Txn) error {
	mut := mulbase.CreateMutation(r.Values(), mulbase.MutateSet)
	_, err := txn.Mutate(ctx, mut)
	return err
}
func (r *Question) GetType() []string {
	if r.Type == nil {
		r.SetType()
	}
	return r.Type
}

func (r *Question) Facets() []string {
	return nil
}

//Fields returns all Scalar fields for this value.
func (r *Question) Fields() mulbase.FieldList {
	return QuestionFields
}

//Sets the types. This DOES NOT include interfaces!
//as they are set in dgraph already.
func (r *Question) SetType() {
	r.Type = []string{
		"Question",
	}
}

//Values returns all the scalar values for this node.
func (r *Question) Values() mulbase.DNode {
	var m QuestionScalars
	m.Text = r.Text
	m.DatePublished = r.DatePublished
	r.SetType()
	m.Node = r.Node
	return &m
}

//Values returns all the scalar values for this node.
//Note that this completely ignores any omitempty tags so use with care.
func (r *Question) MapValues() mulbase.Mapper {
	var m = make(map[string]interface{})
	m["Post.text"] = r.Text
	m["Post.datePublished"] = r.DatePublished
	if r.Uid != "" {
		m["uid"] = r.Uid
	}
	r.SetType()
	m["dgraph.type"] = r.Type
	return m
}

//QuestionScalars is simply to avoid a map[string]interface{}
//It is a mirror of the previous struct with all scalar values.
type QuestionScalars struct {
	mulbase.Node
	Text          string     `json:"Post.text,omitempty"`
	DatePublished *time.Time `json:"Post.datePublished,omitempty"`
}

func (s *QuestionScalars) Values() mulbase.DNode {
	return s
}

func (s *QuestionScalars) MapValues() mulbase.Mapper {
	panic("QuestionScalars called, use the original one instead")
}

func (s *QuestionScalars) Fields() mulbase.FieldList {
	return QuestionFields
}

//End of model.template
type Comment struct {
	//This line declares basic properties for a database node.
	mulbase.Node
	//List of interfaces implemented.
	Post
	//Regular fields
	CommentsOn *Post `json:"Comment.commentsOn,omitempty"`
}

var CommentFields mulbase.FieldList = []mulbase.Field{MakeField("Comment.commentsOn", 0|mulbase.MetaObject|mulbase.MetaReverse), MakeField("Post.text", 0|mulbase.MetaLang), MakeField("Post.datePublished", 0), MakeField("Post.from", 0|mulbase.MetaObject), MakeField("~Comment.commentsOn", 0|mulbase.MetaObject|mulbase.MetaList|mulbase.MetaReverse)}

//Generating constant field values.
const (
	CommentCommentsOnField    mulbase.Predicate = "Comment.commentsOn"
	CommentTextField          mulbase.Predicate = "Post.text"
	CommentDatePublishedField mulbase.Predicate = "Post.datePublished"
	CommentFromField          mulbase.Predicate = "Post.from"
	CommentCommentsField      mulbase.Predicate = "~Comment.commentsOn"
)

//SaveValues saves the node values that
//do not contain any references to other objects.
func (r *Comment) SaveValues(ctx context.Context, txn *mulbase.Txn) error {
	mut := mulbase.CreateMutation(r.Values(), mulbase.MutateSet)
	_, err := txn.Mutate(ctx, mut)
	return err
}
func (r *Comment) GetType() []string {
	if r.Type == nil {
		r.SetType()
	}
	return r.Type
}

func (r *Comment) Facets() []string {
	return nil
}

//Fields returns all Scalar fields for this value.
func (r *Comment) Fields() mulbase.FieldList {
	return CommentFields
}

//Sets the types. This DOES NOT include interfaces!
//as they are set in dgraph already.
func (r *Comment) SetType() {
	r.Type = []string{
		"Comment",
	}
}

//Values returns all the scalar values for this node.
func (r *Comment) Values() mulbase.DNode {
	var m CommentScalars
	m.Text = r.Text
	m.DatePublished = r.DatePublished
	r.SetType()
	m.Node = r.Node
	return &m
}

//Values returns all the scalar values for this node.
//Note that this completely ignores any omitempty tags so use with care.
func (r *Comment) MapValues() mulbase.Mapper {
	var m = make(map[string]interface{})
	m["Post.text"] = r.Text
	m["Post.datePublished"] = r.DatePublished
	if r.Uid != "" {
		m["uid"] = r.Uid
	}
	r.SetType()
	m["dgraph.type"] = r.Type
	return m
}

//CommentScalars is simply to avoid a map[string]interface{}
//It is a mirror of the previous struct with all scalar values.
type CommentScalars struct {
	mulbase.Node
	Text          string     `json:"Post.text,omitempty"`
	DatePublished *time.Time `json:"Post.datePublished,omitempty"`
}

func (s *CommentScalars) Values() mulbase.DNode {
	return s
}

func (s *CommentScalars) MapValues() mulbase.Mapper {
	panic("CommentScalars called, use the original one instead")
}

func (s *CommentScalars) Fields() mulbase.FieldList {
	return CommentFields
}

//End of model.template
type User struct {
	//This line declares basic properties for a database node.
	mulbase.Node
	//Regular fields
	Name string `json:"User.name,omitempty"`
	Pass string `json:"User.pass,omitempty"`
}

var _ = MakeField("User.pass", 0)
var UserFields mulbase.FieldList = []mulbase.Field{MakeField("User.name", 0)}

//Generating constant field values.
const (
	UserNameField mulbase.Predicate = "User.name"
	UserPassField mulbase.Predicate = "User.pass"
)

//SaveValues saves the node values that
//do not contain any references to other objects.
func (r *User) SaveValues(ctx context.Context, txn *mulbase.Txn) error {
	mut := mulbase.CreateMutation(r.Values(), mulbase.MutateSet)
	_, err := txn.Mutate(ctx, mut)
	return err
}
func (r *User) GetType() []string {
	if r.Type == nil {
		r.SetType()
	}
	return r.Type
}

func (r *User) Facets() []string {
	return nil
}

//Fields returns all Scalar fields for this value.
func (r *User) Fields() mulbase.FieldList {
	return UserFields
}

//Sets the types. This DOES NOT include interfaces!
//as they are set in dgraph already.
func (r *User) SetType() {
	r.Type = []string{
		"User",
	}
}

//Values returns all the scalar values for this node.
func (r *User) Values() mulbase.DNode {
	var m UserScalars
	m.Name = r.Name
	r.SetType()
	m.Node = r.Node
	return &m
}

//Values returns all the scalar values for this node.
//Note that this completely ignores any omitempty tags so use with care.
func (r *User) MapValues() mulbase.Mapper {
	var m = make(map[string]interface{})
	m["User.name"] = r.Name
	if r.Uid != "" {
		m["uid"] = r.Uid
	}
	r.SetType()
	m["dgraph.type"] = r.Type
	return m
}

//UserScalars is simply to avoid a map[string]interface{}
//It is a mirror of the previous struct with all scalar values.
type UserScalars struct {
	mulbase.Node
	Name string `json:"User.name,omitempty"`
	Pass string `json:"User.pass,omitempty"`
}

func (s *UserScalars) Values() mulbase.DNode {
	return s
}

func (s *UserScalars) MapValues() mulbase.Mapper {
	panic("UserScalars called, use the original one instead")
}

func (s *UserScalars) Fields() mulbase.FieldList {
	return UserFields
}

//End of model.template
type Error struct {
	//This line declares basic properties for a database node.
	mulbase.Node
	//Regular fields
	Message   string     `json:"Error.message,omitempty"`
	ErrorType string     `json:"Error.errorType,omitempty"`
	Time      *time.Time `json:"Error.time,omitempty"`
}

var ErrorFields mulbase.FieldList = []mulbase.Field{MakeField("Error.message", 0), MakeField("Error.errorType", 0), MakeField("Error.time", 0)}

//Generating constant field values.
const (
	ErrorMessageField   mulbase.Predicate = "Error.message"
	ErrorErrorTypeField mulbase.Predicate = "Error.errorType"
	ErrorTimeField      mulbase.Predicate = "Error.time"
)

//SaveValues saves the node values that
//do not contain any references to other objects.
func (r *Error) SaveValues(ctx context.Context, txn *mulbase.Txn) error {
	mut := mulbase.CreateMutation(r.Values(), mulbase.MutateSet)
	_, err := txn.Mutate(ctx, mut)
	return err
}
func (r *Error) GetType() []string {
	if r.Type == nil {
		r.SetType()
	}
	return r.Type
}

func (r *Error) Facets() []string {
	return nil
}

//Fields returns all Scalar fields for this value.
func (r *Error) Fields() mulbase.FieldList {
	return ErrorFields
}

//Sets the types. This DOES NOT include interfaces!
//as they are set in dgraph already.
func (r *Error) SetType() {
	r.Type = []string{
		"Error",
	}
}

//Values returns all the scalar values for this node.
func (r *Error) Values() mulbase.DNode {
	var m ErrorScalars
	m.Message = r.Message
	m.ErrorType = r.ErrorType
	m.Time = r.Time
	r.SetType()
	m.Node = r.Node
	return &m
}

//Values returns all the scalar values for this node.
//Note that this completely ignores any omitempty tags so use with care.
func (r *Error) MapValues() mulbase.Mapper {
	var m = make(map[string]interface{})
	m["Error.message"] = r.Message
	m["Error.errorType"] = r.ErrorType
	m["Error.time"] = r.Time
	if r.Uid != "" {
		m["uid"] = r.Uid
	}
	r.SetType()
	m["dgraph.type"] = r.Type
	return m
}

//ErrorScalars is simply to avoid a map[string]interface{}
//It is a mirror of the previous struct with all scalar values.
type ErrorScalars struct {
	mulbase.Node
	Message   string     `json:"Error.message,omitempty"`
	ErrorType string     `json:"Error.errorType,omitempty"`
	Time      *time.Time `json:"Error.time,omitempty"`
}

func (s *ErrorScalars) Values() mulbase.DNode {
	return s
}

func (s *ErrorScalars) MapValues() mulbase.Mapper {
	panic("ErrorScalars called, use the original one instead")
}

func (s *ErrorScalars) Fields() mulbase.FieldList {
	return ErrorFields
}

//End of model.template
