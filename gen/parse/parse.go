package parse

import (
	"bytes"
	"fmt"
	"github.com/gobuffalo/packr/v2"
	"go/format"
	"io"
	"io/ioutil"
	"mulbase/gen/graphql-go"
	"mulbase/gen/graphql-go/schema"
	"os"
	"path/filepath"
	"strings"
	"text/template"
)

var builtins = map[string]string{
	"String": "string",
	"Int":    "int",
	"Boolean": "bool",
}

const (
	ModelFileName = "/models.go"
	FunctionFileName = "/gen.go"
)

const (
	preamble = `// Code generated by mulgen. DO NOT EDIT (or feel free but it will be lost!).`
)

func writeHeader(w *bytes.Buffer) {
	_, _ = w.WriteString("package mulgen \n")
	_, _ = w.WriteString(preamble)
	_ = w.WriteByte('\n')

}

func writeImports(imports []string, w io.Writer) {
	var buf bytes.Buffer
	buf.WriteString("import ( \n")
	var newImports = make([]string, len(imports))
	for k,v := range imports {
		newImports[k] = "\"" + v + "\""
	}
	buf.WriteString(strings.Join(newImports, "\n"))
	buf.WriteString("\n)\n")
	_,_ = io.Copy(w, &buf)
}

func goFmt(byt []byte) []byte {
	if byt == nil {
		return nil
	}
	result, err := format.Source(byt)
	if err != nil {
		fmt.Println(string(byt))
		panic(err)
	}
	return result
}


func Parse(input, output string) {
	/*
		First pass. Generate the models.
	*/
	models, err := os.Create(output + ModelFileName)
	if err != nil {
		panic(err)
	}
	defer models.Close()
	fns, err := os.Create(output + FunctionFileName)
	if err != nil {
		panic(err)
	}
	defer fns.Close()
	/*
		Generate string builders. Do not use bufIO as we use gofmt on the result.
	 */
	var modelBuffer bytes.Buffer
	var fnBuffer bytes.Buffer
	/*
		Write the package name.
	*/
	writeHeader(&modelBuffer)
	writeHeader(&fnBuffer)
	/*
		Walk the directory.
	 */
	err = filepath.Walk(input, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			panic(err)
		}
		if !info.IsDir() {
			//This should be safe.
			fd, err := ioutil.ReadFile(path)
			if err != nil {
				panic(err)
			}
			/*
			Use graphQL parser for the schema.
			 */
			sc := graphql.MustParseSchema(string(fd), nil)
			generate(sc.Schema, &modelBuffer, &fnBuffer)
		}
		return nil
	})
	if err != nil {
		panic(err)
	}
	modelData := goFmt(modelBuffer.Bytes())
	fnData := goFmt(fnBuffer.Bytes())

	if modelData == nil || fnData == nil {
		panic("could not properly format code")
	}
	_, err = fns.Write(fnData)
	if err != nil {
		panic(err)
	}
	_,err = models.Write(modelData)
	if err != nil {
		panic(err)
	}
}

func generate(schema *schema.Schema, modelWriter io.Writer, fnWriter io.Writer) {
	createModel(schema, modelWriter)
	processFunctions(schema, fnWriter)
}

//Parses a single GraphQL file and writes to output.
func createModel(s *schema.Schema, output io.Writer) {
	//We now have the schema relevant for the file. First generate the models.
	obj := s.Objects()
	writeImports(modelImports, output)
	/*
		Initially just create the go definitions.
	*/
	for _, vv := range obj {
		buf := makeGoStruct(vv)
		_, err := io.Copy(output, buf)

		if err != nil {
			panic(err)
		}
	}
}

var templates = map[string]string {
	"Get": "get.template",
	"Field": "field.template",
	"Async": "async.template",
	"Model": "model.template",
}
//The box relevant for embedding assets.
var box = packr.New("templates", "./templates")

func getTemplate(name string) *template.Template {
	file, ok := templates[name]
	if !ok {
		return nil
	}
	str, err := box.FindString(file)
	if err != nil {
		panic(err)
	}
	templ, err := template.New(name).Parse(str)
	if err != nil {
		return nil
	}
	return templ

}