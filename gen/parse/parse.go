package parse

import (
	"bytes"
	"fmt"
	"github.com/gobuffalo/packr/v2"
	"go/format"
	"text/template"
)


type Config struct {
	State string
	Input string
	Output string
	Package string
}
var conf *Config
var parseState string

//converts graphql -> go
func getBuiltIn(key string) (string, bool) {
	val,ok := builtins[key]
	return val, ok
}

const (
	ModelFileName = "/models.go"
	FunctionFileName = "/generated.go"
	EnumFileName = "/enums.go"
	SchemaName = "/dgraph_schema.graphql"
	CustomsFileName = "/customs.go"
)

const (
	preamble = `// Code generated by gen. DO NOT EDIT (or feel free but it will be lost!).`
)

func (g *Generator) writeHeader(w *bytes.Buffer) {
	return
	_, _ = w.WriteString("package " + g.config.Package + " \n")
	_, _ = w.WriteString(preamble)
	_ = w.WriteByte('\n')

}

func addImport(imp string, imports []string) []string {
	for _,v := range imports {
		if v == imp {
			return imports
		}
	}
	return append(imports, imp)
}

func goFmt(byt []byte) []byte {
	if byt == nil {
		return nil
	}
	result, err := format.Source(byt)
	if err != nil {
		fmt.Println(string(byt))
		panic(err)
	}
	return result
}

//Parse parses the directory input and outputs go files to the directory output.
func Parse(config *Config) {
	gen := newGenerator(config)
	gen.Run()
	/*models, err := os.Create(config.Output + ModelFileName)
	if err != nil {
		panic(err)
	}
	defer models.Close()
	fns, err := os.Create(config.Output + FunctionFileName)
	if err != nil {
		panic(err)
	}
	defer fns.Close()
	enum, err := os.Create(config.Output + EnumFileName)
	if err != nil {
		panic(err)
	}
	defer enum.Close()*/
	/*
		Generate string builders. Do not use bufIO as we use gofmt on the result.
	 */
	/*var modelBuffer bytes.Buffer
	var fnBuffer bytes.Buffer
	var enumBuffer bytes.Buffer*/
	/*
		Write the package name.
	*/
	/*writeHeader(&modelBuffer)
	writeHeader(&fnBuffer)
	writeHeader(&enumBuffer)*/
	/*
		Walk the directory.
	 */
	/*
	if parseState == "graphql" {
		sch, err := os.Create(config.Output + SchemaName)
		if err != nil {
			panic(err)
		}
		defer sch.Close()
	}
	if parseState == "dgraph" {
		dgraphSch, err := os.Create(config.Output + "/dgraph.txt")
		if err != nil {
			panic(err)
		}
		defer dgraphSch.Close()
		makeSchema(dgraphSch)
	}
	if len(customFields) > 0 {
		file, err := os.Create(config.Output + CustomsFileName)

		var sb bytes.Buffer
		writeHeader(&sb)
		_,_ = io.Copy(file, &sb)
		var imports = []string{"github.com/Vliro/mulbase"}
		writeImports(imports, file)
		if err != nil {
			panic(err)
		}
		defer file.Close()
		writeCustoms(customFields, file)
	}*/
}

//Below lies code for getting files and templates.

//The box relevant for embedding assets.
var box = packr.New("templates", "./templates")

var graphBox = packr.New("graphql", "./graphql")

func getTemplate(name string) *template.Template {
	file, ok := templates[name]
	if !ok {
		return nil
	}
	str, err := box.FindString(file)
	if err != nil {
		panic(err)
	}
	templ, err := template.New(name).Parse(str)
	if err != nil {
		panic(err)
	}
	return templ
}

func getGraphFile(name string) []byte {
	file, err := graphBox.Find(name)
	if err != nil {
		panic(err)
	}
	return file
}