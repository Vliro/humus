package parse

import (
	"bytes"
	"fmt"
	"github.com/BurntSushi/toml"
	"github.com/gobuffalo/packr/v2"
	"go/format"
	"io"
	"io/ioutil"
	"github.com/Vliro/mulbase/gen/graphql-go"
	"github.com/Vliro/mulbase/gen/graphql-go/schema"
	"os"
	"path/filepath"
	"strings"
	"text/template"
)


var parseState string

func getBuiltIn(key string) (string, bool) {
	val,ok := builtins[key]
	if arr := strings.Split(val, "."); len(arr) > 1 {
		modelImports = addImport(arr[0], modelImports)
	}
	return val, ok
}

const (
	ModelFileName = "/mulgen.go"
	FunctionFileName = "/gen.go"
	EnumFileName = "/enums.go"
	SchemaName = "/dgraph_schema.graphql"
)

const (
	preamble = `// Code generated by mulgen. DO NOT EDIT (or feel free but it will be lost!).`
)

func writeHeader(w *bytes.Buffer) {
	_, _ = w.WriteString("package mulgen \n")
	_, _ = w.WriteString(preamble)
	_ = w.WriteByte('\n')

}

func addImport(imp string, imports []string) []string {
	for _,v := range imports {
		if v == imp {
			return imports
		}
	}
	return append(imports, imp)
}

func writeImports(imports []string, w io.Writer) {
	var buf bytes.Buffer
	buf.WriteString("import ( \n")
	var newImports = make([]string, len(imports))
	for k,v := range imports {
		newImports[k] = "\"" + v + "\""
	}
	buf.WriteString(strings.Join(newImports, "\n"))
	buf.WriteString("\n)\n")
	_,_ = io.Copy(w, &buf)
}

func goFmt(byt []byte) []byte {
	if byt == nil {
		return nil
	}
	result, err := format.Source(byt)
	if err != nil {
		fmt.Println(string(byt))
		panic(err)
	}
	return result
}

//Parse parses the directory input and outputs go files to the directory output.
func Parse(input, output string, mode string) {
	/*
		First pass. Generate the mulgen.
	*/
	parseState = mode
	models, err := os.Create(output + ModelFileName)
	if err != nil {
		panic(err)
	}
	defer models.Close()
	fns, err := os.Create(output + FunctionFileName)
	if err != nil {
		panic(err)
	}
	defer fns.Close()
	enum, err := os.Create(output + EnumFileName)
	if err != nil {
		panic(err)
	}
	defer enum.Close()
	/*
		Generate string builders. Do not use bufIO as we use gofmt on the result.
	 */
	var modelBuffer bytes.Buffer
	var fnBuffer bytes.Buffer
	var enumBuffer bytes.Buffer
	/*
		Write the package name.
	*/
	writeHeader(&modelBuffer)
	writeHeader(&fnBuffer)
	writeHeader(&enumBuffer)
	/*
		Walk the directory.
	 */
	var resultingFile bytes.Buffer
	var hasFile = false
	err = filepath.Walk(input, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			panic(err)
		}
		if !info.IsDir() {
			//This should be safe.
			fd, err := ioutil.ReadFile(path)
			if err != nil {
				panic(err)
			}
			/*
			Use graphQL parser for the schema.
			 */
			//
			if fp := filepath.Ext(info.Name()); fp == ".toml" {
				meta = parseMeta(bytes.NewReader(fd))
				return nil
			}
			if fp := filepath.Ext(info.Name()); fp != ".graphql" {
				return nil
			}
			if info.Name() == "dgraph_schema.graphql" {
				return nil
			}
			hasFile = true
			resultingFile.Write(fd)
			resultingFile.WriteByte('\n')
			//Ensure we add the proper header.
		}
		return nil
	})
	//No file found. Don't do anything.
	if !hasFile {
		return
	}
	data := getGraphFile("error.graphql")
	if data == nil {
		panic("something went horribly wrong")
	}
	resultingFile.Write(data)
	/*
		Parse the entire schema, go-fmt the code and write to the file.
	 */
	sc := graphql.MustParseSchema(resultingFile.String(), nil)
	generate(sc.Schema, &modelBuffer, &fnBuffer, &enumBuffer)
	if err != nil {
		panic(err)
	}
	modelData := goFmt(modelBuffer.Bytes())
	fnData := goFmt(fnBuffer.Bytes())
	enumData := goFmt(enumBuffer.Bytes())
	if modelData == nil || fnData == nil || enumData == nil {
		panic("could not properly format code")
	}
	_, err = fns.Write(fnData)
	if err != nil {
		panic(err)
	}
	_,err = models.Write(modelData)
	if err != nil {
		panic(err)
	}
	_, err = enum.Write(enumData)
	if err != nil {
		panic(err)
	}
	if parseState == "graphql" {
		sch, err := os.Create(output + SchemaName)
		if err != nil {
			return
		}
		defer sch.Close()
	}
	if parseState == "dgraph" {
		dgraphSch, err := os.Create(output + "/dgraph.txt")
		if err != nil {
			return
		}
		defer dgraphSch.Close()
		makeSchema(dgraphSch)
	}
}
//make models and functions.
func generate(schema *schema.Schema, modelWriter io.Writer, fnWriter io.Writer, enumWriter io.Writer) {
	_,m := createModel(schema, modelWriter, enumWriter)
	processFunctions(schema, fnWriter, m)
}

//Parses a single GraphQL file and writes to output.
//Also generates a field map.
func createModel(s *schema.Schema, output io.Writer, enumWriter io.Writer) (error, map[string][]Field) {
	//We now have the schema relevant for the file. First generate the mulgen.
	obj := s.Objects()
	//Use a temporary buffer to ensure we add imports last.
	var tempBuffer bytes.Buffer
	var fieldMap = make(map[string][]Field)
	/*
		Initially just create the go definitions.
	*/

	var interfaces = make(map[string]*schema.Interface)
	var enums = make(map[string]*schema.Enum)
	/*
		Get a list of interfaces and enums
	 */
	for _,vv := range s.Types {
		switch a := vv.(type) {
		case *schema.Interface:
			interfaces[a.Name] = a
		case *schema.Enum:
			if a.Name[0] == '_' {
				continue
			}
			enums[a.Name] = a
		}
		/*for _,v := range vv.Interfaces {
			if _, ok :=interfaces[v.Name]; !ok {
				interfaces[v.Name] = v
			}
		}*/
	}
	/*
		Write the enums.
	 */
	makeEnums(enums, enumWriter)
	/*
		Write the interfaces first as we use these to extend the scalar values.
	 */
	for _,v := range interfaces {
		buf, m := makeGoInterface(v)
		fieldMap[v.Name] = m
		_, err := io.Copy(&tempBuffer, buf)
		if err != nil {
			panic(err)
		}
	}
	/*
		Write the objects.
	 */
	for _, vv := range obj {
		buf,m := makeGoStruct(vv, fieldMap)
		fieldMap[vv.Name] = m
		_, err := io.Copy(&tempBuffer, buf)

		if err != nil {
			panic(err)
		}
	}
	writeImports(modelImports, output)
	_ , err := io.Copy(output, &tempBuffer)
	return err, fieldMap
}

//The box relevant for embedding assets.
var box = packr.New("templates", "./templates")

var graphBox = packr.New("graphql", "./graphql")

func getTemplate(name string) *template.Template {
	file, ok := templates[name]
	if !ok {
		return nil
	}
	str, err := box.FindString(file)
	if err != nil {
		panic(err)
	}
	templ, err := template.New(name).Parse(str)
	if err != nil {
		panic(err)
	}
	return templ
}

func getGraphFile(name string) []byte {
	file, err := graphBox.Find(name)
	if err != nil {
		panic(err)
	}
	return file
}
//Meta allows you to specify how the structs are handled in go.
//*.toml files allow you to specify properties that act independent
//of the dgraph database. For instance, you generally don't want password
//fields to be queried per default and/or mutated at times.
//Specifying it as a password excludes it from all default queries.
type Meta struct {
	Password bool
}

func parseMeta(input io.Reader) map[string]map[string]Meta {
	m := make(map[string]map[string]Meta)
	_, err := toml.DecodeReader(input, &m)
	if err != nil {
		panic(err)
	}
	return m
}

var meta map[string]map[string]Meta

func getMetaValue(name string) *Meta {
	names := strings.Split(name, ".")
	if len(names) != 2 {
		return nil
	}
	if val, ok := meta[names[0]]; ok {
		if md, ok := val[names[1]]; ok {
			return &md
		}
	}
	return nil
}