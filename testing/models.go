package gen

//Code generated by mulgen. DO NOT EDIT (i mean, it will all be lost in the void)

import (
	"context"
	"github.com/Vliro/humus"
	"strconv"
	"time"
)

var _ context.Context
var _ time.Time
var _ humus.Fields
var _ = strconv.IntSize

//Created from a GraphQL interface.
type Post struct {
	//This line declares basic properties for a database node.
	humus.Node
	Text          string     `json:"text" predicate:"Post.text,omitempty"`
	DatePublished *time.Time `json:"datePublished" predicate:"Post.datePublished,omitempty"`
}

var PostFields humus.Fields = humus.FieldList([]humus.Field{MakeField("Post.text", 0), MakeField("Post.datePublished", 0)})

//Generating constant field values.
const (
	PostTextField          humus.Predicate = "Post.text"
	PostDatePublishedField humus.Predicate = "Post.datePublished"
)

//SaveValues saves the node values that
//do not contain any references to other objects.
//Not needed for now.
/*
func (r *Post) SaveValues(ctx context.Context, txn *humus.Txn) error {
    mut := humus.CreateMutation(r.Values(), humus.MutateSet)
    _,err := txn.Mutate(ctx, mut)
    return err
}
*/
func (r *Post) GetType() []string {
	return _PostTypes
}

//Relative returns a new Post containing
//only the node component of it, useful in saving edges
//while ensuring data stability.
func (r *Post) Relative() *Post {
	var x = new(Post)
	x.Node = r.Node
	return x
}

func (r *Post) Facets() []string {
	return nil
}

//Fields returns all Scalar fields for this value.
func (r *Post) Fields() humus.Fields {
	return PostFields
}

var _PostTypes = []string{
	"Post",
}

//Sets the types. This DOES NOT include interfaces!
//as they are set in dgraph already.
func (r *Post) SetType() {
	r.Node.Type = _PostTypes
}

/*
//Values returns all the scalar values for this node.
func (r *Post) Values() humus.DNode{
   var m PostScalars
   m.Text= r.Text
       m.DatePublished= r.DatePublished
       r.SetType()
   m.Node = r.Node
   return &m
}
*/
/*
//Values returns all the scalar values for this node.
//Note that this completely ignores any omitempty tags so use with care.
func (r *Post) MapValues() humus.Mapper {
   var m = make(map[string]interface{})
   m["Post.text"]= r.Text
      m["Post.datePublished"]= r.DatePublished
      if r.Uid != "" {
      m["uid"] = r.Uid
   }
    r.SetType()
    m["dgraph.type"] = r.Type
    return m
}
*/
/*
//PostScalars is simply to avoid a map[string]interface{}
//It is a mirror of the previous struct with all scalar values.
type PostScalars struct {
    humus.Node
    Text string `json:"Post.text,omitempty"`
    DatePublished *time.Time `json:"Post.datePublished,omitempty"`

}

func (s *PostScalars) Values() humus.DNode {
    return s
}

func (s *PostScalars) Fields() humus.FieldList {
    return PostFields
}
*/
//End of model.template
type Question struct {
	//This line declares basic properties for a database node.
	humus.Node
	//List of interfaces implemented.
	Post
	//Regular fields
	Title    string     `json:"title" predicate:"Question.title,omitempty"`
	From     *User      `json:"from" predicate:"Question.from,omitempty"`
	Comments []*Comment `json:"comments" predicate:"Question.comments,omitempty"`
}

var QuestionFields humus.Fields = humus.FieldList([]humus.Field{MakeField("Question.title", 0), MakeField("Question.from", 0|humus.MetaObject), MakeField("Question.comments", 0|humus.MetaObject|humus.MetaList), MakeField("Post.text", 0), MakeField("Post.datePublished", 0)})

//Generating constant field values.
const (
	QuestionTitleField         humus.Predicate = "Question.title"
	QuestionFromField          humus.Predicate = "Question.from"
	QuestionCommentsField      humus.Predicate = "Question.comments"
	QuestionTextField          humus.Predicate = "Post.text"
	QuestionDatePublishedField humus.Predicate = "Post.datePublished"
)

//SaveValues saves the node values that
//do not contain any references to other objects.
//Not needed for now.
/*
func (r *Question) SaveValues(ctx context.Context, txn *humus.Txn) error {
    mut := humus.CreateMutation(r.Values(), humus.MutateSet)
    _,err := txn.Mutate(ctx, mut)
    return err
}
*/
func (r *Question) GetType() []string {
	return _QuestionTypes
}

//Relative returns a new Question containing
//only the node component of it, useful in saving edges
//while ensuring data stability.
func (r *Question) Relative() *Question {
	var x = new(Question)
	x.Node = r.Node
	return x
}

func (r *Question) Facets() []string {
	return nil
}

//Fields returns all Scalar fields for this value.
func (r *Question) Fields() humus.Fields {
	return QuestionFields
}

var _QuestionTypes = []string{
	"Question",
	"Post",
}

func (r *Question) AsPost() *Post {
	r.Post.Node = r.Node
	return &r.Post
}

//Sets the types. This DOES NOT include interfaces!
//as they are set in dgraph already.
func (r *Question) SetType() {
	r.Node.Type = _QuestionTypes
}

/*
//Values returns all the scalar values for this node.
func (r *Question) Values() humus.DNode{
   var m QuestionScalars
   m.Title= r.Title
       m.Text= r.Text
       m.DatePublished= r.DatePublished
       r.SetType()
   m.Node = r.Node
   return &m
}
*/
/*
//Values returns all the scalar values for this node.
//Note that this completely ignores any omitempty tags so use with care.
func (r *Question) MapValues() humus.Mapper {
   var m = make(map[string]interface{})
   m["Question.title"]= r.Title
      m["Post.text"]= r.Text
      m["Post.datePublished"]= r.DatePublished
      if r.Uid != "" {
      m["uid"] = r.Uid
   }
    r.SetType()
    m["dgraph.type"] = r.Type
    return m
}
*/
/*
//QuestionScalars is simply to avoid a map[string]interface{}
//It is a mirror of the previous struct with all scalar values.
type QuestionScalars struct {
    humus.Node
    Title string `json:"Question.title,omitempty"`
    Text string `json:"Post.text,omitempty"`
    DatePublished *time.Time `json:"Post.datePublished,omitempty"`

}

func (s *QuestionScalars) Values() humus.DNode {
    return s
}

func (s *QuestionScalars) Fields() humus.FieldList {
    return QuestionFields
}
*/
//End of model.template
type Comment struct {
	//This line declares basic properties for a database node.
	humus.Node
	//List of interfaces implemented.
	Post
	//Regular fields
	From *User `json:"from" predicate:"Comment.from,omitempty"`
}

var CommentFields humus.Fields = humus.FieldList([]humus.Field{MakeField("Comment.from", 0|humus.MetaObject), MakeField("Post.text", 0), MakeField("Post.datePublished", 0)})

//Generating constant field values.
const (
	CommentFromField          humus.Predicate = "Comment.from"
	CommentTextField          humus.Predicate = "Post.text"
	CommentDatePublishedField humus.Predicate = "Post.datePublished"
)

//SaveValues saves the node values that
//do not contain any references to other objects.
//Not needed for now.
/*
func (r *Comment) SaveValues(ctx context.Context, txn *humus.Txn) error {
    mut := humus.CreateMutation(r.Values(), humus.MutateSet)
    _,err := txn.Mutate(ctx, mut)
    return err
}
*/
func (r *Comment) GetType() []string {
	return _CommentTypes
}

//Relative returns a new Comment containing
//only the node component of it, useful in saving edges
//while ensuring data stability.
func (r *Comment) Relative() *Comment {
	var x = new(Comment)
	x.Node = r.Node
	return x
}

func (r *Comment) Facets() []string {
	return nil
}

//Fields returns all Scalar fields for this value.
func (r *Comment) Fields() humus.Fields {
	return CommentFields
}

var _CommentTypes = []string{
	"Comment",
	"Post",
}

func (r *Comment) AsPost() *Post {
	r.Post.Node = r.Node
	return &r.Post
}

//Sets the types. This DOES NOT include interfaces!
//as they are set in dgraph already.
func (r *Comment) SetType() {
	r.Node.Type = _CommentTypes
}

/*
//Values returns all the scalar values for this node.
func (r *Comment) Values() humus.DNode{
   var m CommentScalars
   m.Text= r.Text
       m.DatePublished= r.DatePublished
       r.SetType()
   m.Node = r.Node
   return &m
}
*/
/*
//Values returns all the scalar values for this node.
//Note that this completely ignores any omitempty tags so use with care.
func (r *Comment) MapValues() humus.Mapper {
   var m = make(map[string]interface{})
   m["Post.text"]= r.Text
      m["Post.datePublished"]= r.DatePublished
      if r.Uid != "" {
      m["uid"] = r.Uid
   }
    r.SetType()
    m["dgraph.type"] = r.Type
    return m
}
*/
/*
//CommentScalars is simply to avoid a map[string]interface{}
//It is a mirror of the previous struct with all scalar values.
type CommentScalars struct {
    humus.Node
    Text string `json:"Post.text,omitempty"`
    DatePublished *time.Time `json:"Post.datePublished,omitempty"`

}

func (s *CommentScalars) Values() humus.DNode {
    return s
}

func (s *CommentScalars) Fields() humus.FieldList {
    return CommentFields
}
*/
//End of model.template
type User struct {
	//This line declares basic properties for a database node.
	humus.Node
	//Regular fields
	Name  string `json:"name" predicate:"User.name,omitempty"`
	Email string `json:"email" predicate:"User.email,omitempty"`
}

var UserFields humus.Fields = humus.FieldList([]humus.Field{MakeField("User.name", 0), MakeField("User.email", 0)})

//Generating constant field values.
const (
	UserNameField  humus.Predicate = "User.name"
	UserEmailField humus.Predicate = "User.email"
)

//SaveValues saves the node values that
//do not contain any references to other objects.
//Not needed for now.
/*
func (r *User) SaveValues(ctx context.Context, txn *humus.Txn) error {
    mut := humus.CreateMutation(r.Values(), humus.MutateSet)
    _,err := txn.Mutate(ctx, mut)
    return err
}
*/
func (r *User) GetType() []string {
	return _UserTypes
}

//Relative returns a new User containing
//only the node component of it, useful in saving edges
//while ensuring data stability.
func (r *User) Relative() *User {
	var x = new(User)
	x.Node = r.Node
	return x
}

func (r *User) Facets() []string {
	return nil
}

//Fields returns all Scalar fields for this value.
func (r *User) Fields() humus.Fields {
	return UserFields
}

var _UserTypes = []string{
	"User",
}

//Sets the types. This DOES NOT include interfaces!
//as they are set in dgraph already.
func (r *User) SetType() {
	r.Node.Type = _UserTypes
}

/*
//Values returns all the scalar values for this node.
func (r *User) Values() humus.DNode{
   var m UserScalars
   m.Name= r.Name
       m.Email= r.Email
       r.SetType()
   m.Node = r.Node
   return &m
}
*/
/*
//Values returns all the scalar values for this node.
//Note that this completely ignores any omitempty tags so use with care.
func (r *User) MapValues() humus.Mapper {
   var m = make(map[string]interface{})
   m["User.name"]= r.Name
      m["User.email"]= r.Email
      if r.Uid != "" {
      m["uid"] = r.Uid
   }
    r.SetType()
    m["dgraph.type"] = r.Type
    return m
}
*/
/*
//UserScalars is simply to avoid a map[string]interface{}
//It is a mirror of the previous struct with all scalar values.
type UserScalars struct {
    humus.Node
    Name string `json:"User.name,omitempty"`
    Email string `json:"User.email,omitempty"`

}

func (s *UserScalars) Values() humus.DNode {
    return s
}

func (s *UserScalars) Fields() humus.FieldList {
    return UserFields
}
*/
//End of model.template
type Error struct {
	//This line declares basic properties for a database node.
	humus.Node
	//Regular fields
	Message   string     `json:"message" predicate:"Error.message,omitempty"`
	ErrorType string     `json:"errorType" predicate:"Error.errorType,omitempty"`
	Time      *time.Time `json:"time" predicate:"Error.time,omitempty"`
}

var ErrorFields humus.Fields = humus.FieldList([]humus.Field{MakeField("Error.message", 0), MakeField("Error.errorType", 0), MakeField("Error.time", 0)})

//Generating constant field values.
const (
	ErrorMessageField   humus.Predicate = "Error.message"
	ErrorErrorTypeField humus.Predicate = "Error.errorType"
	ErrorTimeField      humus.Predicate = "Error.time"
)

//SaveValues saves the node values that
//do not contain any references to other objects.
//Not needed for now.
/*
func (r *Error) SaveValues(ctx context.Context, txn *humus.Txn) error {
    mut := humus.CreateMutation(r.Values(), humus.MutateSet)
    _,err := txn.Mutate(ctx, mut)
    return err
}
*/
func (r *Error) GetType() []string {
	return _ErrorTypes
}

//Relative returns a new Error containing
//only the node component of it, useful in saving edges
//while ensuring data stability.
func (r *Error) Relative() *Error {
	var x = new(Error)
	x.Node = r.Node
	return x
}

func (r *Error) Facets() []string {
	return nil
}

//Fields returns all Scalar fields for this value.
func (r *Error) Fields() humus.Fields {
	return ErrorFields
}

var _ErrorTypes = []string{
	"Error",
}

//Sets the types. This DOES NOT include interfaces!
//as they are set in dgraph already.
func (r *Error) SetType() {
	r.Node.Type = _ErrorTypes
}

/*
//Values returns all the scalar values for this node.
func (r *Error) Values() humus.DNode{
   var m ErrorScalars
   m.Message= r.Message
       m.ErrorType= r.ErrorType
       m.Time= r.Time
       r.SetType()
   m.Node = r.Node
   return &m
}
*/
/*
//Values returns all the scalar values for this node.
//Note that this completely ignores any omitempty tags so use with care.
func (r *Error) MapValues() humus.Mapper {
   var m = make(map[string]interface{})
   m["Error.message"]= r.Message
      m["Error.errorType"]= r.ErrorType
      m["Error.time"]= r.Time
      if r.Uid != "" {
      m["uid"] = r.Uid
   }
    r.SetType()
    m["dgraph.type"] = r.Type
    return m
}
*/
/*
//ErrorScalars is simply to avoid a map[string]interface{}
//It is a mirror of the previous struct with all scalar values.
type ErrorScalars struct {
    humus.Node
    Message string `json:"Error.message,omitempty"`
    ErrorType string `json:"Error.errorType,omitempty"`
    Time *time.Time `json:"Error.time,omitempty"`

}

func (s *ErrorScalars) Values() humus.DNode {
    return s
}

func (s *ErrorScalars) Fields() humus.FieldList {
    return ErrorFields
}
*/
//End of model.template
