package gen

//Code generated by mulgen. DO NOT EDIT (i mean, it will all be lost in the void)

import (
	"context"
	"github.com/Vliro/mulbase"
	"time"
)

var _ context.Context
var _ time.Time
var _ mulbase.Fields

//Created from a GraphQL interface.
type Message struct {
	//This line declares basic properties for a database node.
	mulbase.Node
	From    *User      `json:"Message.from,omitempty"`
	Content string     `json:"Message.content,omitempty"`
	Time    *time.Time `json:"Message.time,omitempty"`
}

var MessageFields mulbase.FieldList = []mulbase.Field{MakeField("Message.from", 0|mulbase.MetaObject), MakeField("Message.content", 0), MakeField("Message.time", 0)}

//Generating constant field values.
const (
	MessageFromField    mulbase.Predicate = "Message.from"
	MessageContentField mulbase.Predicate = "Message.content"
	MessageTimeField    mulbase.Predicate = "Message.time"
)

//SaveValues saves the node values that
//do not contain any references to other objects.
func (r *Message) SaveValues(ctx context.Context, txn *mulbase.Txn) error {
	mut := mulbase.CreateMutation(r.Values(), mulbase.QuerySet)
	err := txn.Query(ctx, mut)
	return err
}
func (r *Message) GetType() []string {
	if r.Type == nil {
		r.SetType()
	}
	return r.Type
}

//Fields returns all Scalar fields for this value.
func (r *Message) Fields() mulbase.FieldList {
	return MessageFields
}

//Sets the types. This DOES NOT include interfaces!
//as they are set in dgraph already.
func (r *Message) SetType() {
	r.Type = []string{
		"Message",
	}
}

//Values returns all the scalar values for this node.
func (r *Message) Values() mulbase.DNode {
	var m MessageScalars
	m.Content = r.Content
	m.Time = r.Time
	r.SetType()
	m.Node = r.Node
	return &m
}

//Values returns all the scalar values for this node.
func (r *Message) MapValues() mulbase.Mapper {
	var m = make(map[string]interface{}, 2)
	m["Message.content"] = r.Content
	m["Message.time"] = r.Time
	if r.Uid != "" {
		m["uid"] = r.Uid
	}
	r.SetType()
	m["dgraph.type"] = r.Type
	return m
}

//MessageScalars is simply to avoid a map[string]interface{}
//It is a mirror of the previous struct with all scalar values.
type MessageScalars struct {
	mulbase.Node
	Content string     `json:"Message.content,omitempty"`
	Time    *time.Time `json:"Message.time,omitempty"`
}

func (s *MessageScalars) Values() mulbase.DNode {
	return s
}

func (s *MessageScalars) MapValues() mulbase.Mapper {
	panic("MessageScalars called, use the original one instead")
}

func (s *MessageScalars) Fields() mulbase.FieldList {
	return MessageFields
}

//End of model.template
type Level struct {
	//This line declares basic properties for a database node.
	mulbase.Node
	//Regular fields
	Name      string         `json:"Level.name,omitempty"`
	Password  string         `json:"Level.password,omitempty"`
	Hash      string         `json:"Level.hash,omitempty"`
	Size      int            `json:"Level.size,omitempty"`
	Updated   *time.Time     `json:"Level.updated,omitempty"`
	PlayCount int            `json:"Level.playCount,omitempty"`
	Live      bool           `json:"Level.live,omitempty"`
	Rating    float64        `json:"Level.rating,omitempty"`
	Owner     *User          `json:"Level.owner,omitempty"`
	Version   *LevelVersion  `json:"Level.version,omitempty"`
	Versions  []LevelVersion `json:"Level.versions,omitempty"`
}

var LevelFields mulbase.FieldList = []mulbase.Field{MakeField("Level.name", 0), MakeField("Level.password", 0), MakeField("Level.hash", 0), MakeField("Level.size", 0), MakeField("Level.updated", 0), MakeField("Level.playCount", 0), MakeField("Level.live", 0), MakeField("Level.rating", 0), MakeField("Level.owner", 0|mulbase.MetaObject|mulbase.MetaReverse), MakeField("Level.version", 0|mulbase.MetaObject), MakeField("Level.versions", 0|mulbase.MetaObject|mulbase.MetaList)}

//Generating constant field values.
const (
	LevelNameField      mulbase.Predicate = "Level.name"
	LevelPasswordField  mulbase.Predicate = "Level.password"
	LevelHashField      mulbase.Predicate = "Level.hash"
	LevelSizeField      mulbase.Predicate = "Level.size"
	LevelUpdatedField   mulbase.Predicate = "Level.updated"
	LevelPlayCountField mulbase.Predicate = "Level.playCount"
	LevelLiveField      mulbase.Predicate = "Level.live"
	LevelRatingField    mulbase.Predicate = "Level.rating"
	LevelOwnerField     mulbase.Predicate = "Level.owner"
	LevelVersionField   mulbase.Predicate = "Level.version"
	LevelVersionsField  mulbase.Predicate = "Level.versions"
)

//SaveValues saves the node values that
//do not contain any references to other objects.
func (r *Level) SaveValues(ctx context.Context, txn *mulbase.Txn) error {
	mut := mulbase.CreateMutation(r.Values(), mulbase.QuerySet)
	err := txn.Query(ctx, mut)
	return err
}
func (r *Level) GetType() []string {
	if r.Type == nil {
		r.SetType()
	}
	return r.Type
}

//Fields returns all Scalar fields for this value.
func (r *Level) Fields() mulbase.FieldList {
	return LevelFields
}

//Sets the types. This DOES NOT include interfaces!
//as they are set in dgraph already.
func (r *Level) SetType() {
	r.Type = []string{
		"Level",
	}
}

//Values returns all the scalar values for this node.
func (r *Level) Values() mulbase.DNode {
	var m LevelScalars
	m.Name = r.Name
	m.Password = r.Password
	m.Hash = r.Hash
	m.Size = r.Size
	m.PlayCount = r.PlayCount
	m.Live = r.Live
	m.Rating = r.Rating
	r.SetType()
	m.Node = r.Node
	return &m
}

//Values returns all the scalar values for this node.
func (r *Level) MapValues() mulbase.Mapper {
	var m = make(map[string]interface{}, 7)
	m["Level.name"] = r.Name
	m["Level.password"] = r.Password
	m["Level.hash"] = r.Hash
	m["Level.size"] = r.Size
	m["Level.playCount"] = r.PlayCount
	m["Level.live"] = r.Live
	m["Level.rating"] = r.Rating
	if r.Uid != "" {
		m["uid"] = r.Uid
	}
	r.SetType()
	m["dgraph.type"] = r.Type
	return m
}

//LevelScalars is simply to avoid a map[string]interface{}
//It is a mirror of the previous struct with all scalar values.
type LevelScalars struct {
	mulbase.Node
	Name      string  `json:"Level.name,omitempty"`
	Password  string  `json:"Level.password,omitempty"`
	Hash      string  `json:"Level.hash,omitempty"`
	Size      int     `json:"Level.size,omitempty"`
	PlayCount int     `json:"Level.playCount,omitempty"`
	Live      bool    `json:"Level.live,omitempty"`
	Rating    float64 `json:"Level.rating,omitempty"`
}

func (s *LevelScalars) Values() mulbase.DNode {
	return s
}

func (s *LevelScalars) MapValues() mulbase.Mapper {
	panic("LevelScalars called, use the original one instead")
}

func (s *LevelScalars) Fields() mulbase.FieldList {
	return LevelFields
}

//End of model.template
type LevelVersion struct {
	//This line declares basic properties for a database node.
	mulbase.Node
	//Regular fields
	Version     int        `json:"LevelVersion.version,omitempty"`
	MaxTime     int        `json:"LevelVersion.maxTime,omitempty"`
	MinLevel    int        `json:"LevelVersion.minLevel,omitempty"`
	Description string     `json:"LevelVersion.description,omitempty"`
	GameMode    string     `json:"LevelVersion.gameMode,omitempty"`
	Song        int        `json:"LevelVersion.song,omitempty"`
	Gravity     float64    `json:"LevelVersion.gravity,omitempty"`
	Items       []Item     `json:"LevelVersion.items,omitempty"`
	Credits     string     `json:"LevelVersion.credits,omitempty"`
	Created     *time.Time `json:"LevelVersion.created,omitempty"`
}

var LevelVersionFields mulbase.FieldList = []mulbase.Field{MakeField("LevelVersion.version", 0), MakeField("LevelVersion.maxTime", 0), MakeField("LevelVersion.minLevel", 0), MakeField("LevelVersion.description", 0), MakeField("LevelVersion.gameMode", 0), MakeField("LevelVersion.song", 0), MakeField("LevelVersion.gravity", 0), MakeField("LevelVersion.items", 0|mulbase.MetaList), MakeField("LevelVersion.credits", 0), MakeField("LevelVersion.created", 0)}

//Generating constant field values.
const (
	LevelVersionVersionField     mulbase.Predicate = "LevelVersion.version"
	LevelVersionMaxTimeField     mulbase.Predicate = "LevelVersion.maxTime"
	LevelVersionMinLevelField    mulbase.Predicate = "LevelVersion.minLevel"
	LevelVersionDescriptionField mulbase.Predicate = "LevelVersion.description"
	LevelVersionGameModeField    mulbase.Predicate = "LevelVersion.gameMode"
	LevelVersionSongField        mulbase.Predicate = "LevelVersion.song"
	LevelVersionGravityField     mulbase.Predicate = "LevelVersion.gravity"
	LevelVersionItemsField       mulbase.Predicate = "LevelVersion.items"
	LevelVersionCreditsField     mulbase.Predicate = "LevelVersion.credits"
	LevelVersionCreatedField     mulbase.Predicate = "LevelVersion.created"
)

//SaveValues saves the node values that
//do not contain any references to other objects.
func (r *LevelVersion) SaveValues(ctx context.Context, txn *mulbase.Txn) error {
	mut := mulbase.CreateMutation(r.Values(), mulbase.QuerySet)
	err := txn.Query(ctx, mut)
	return err
}
func (r *LevelVersion) GetType() []string {
	if r.Type == nil {
		r.SetType()
	}
	return r.Type
}

//Fields returns all Scalar fields for this value.
func (r *LevelVersion) Fields() mulbase.FieldList {
	return LevelVersionFields
}

//Sets the types. This DOES NOT include interfaces!
//as they are set in dgraph already.
func (r *LevelVersion) SetType() {
	r.Type = []string{
		"LevelVersion",
	}
}

//Values returns all the scalar values for this node.
func (r *LevelVersion) Values() mulbase.DNode {
	var m LevelVersionScalars
	m.Version = r.Version
	m.MaxTime = r.MaxTime
	m.MinLevel = r.MinLevel
	m.Description = r.Description
	m.GameMode = r.GameMode
	m.Song = r.Song
	m.Gravity = r.Gravity
	m.Items = r.Items
	m.Credits = r.Credits
	m.Created = r.Created
	r.SetType()
	m.Node = r.Node
	return &m
}

//Values returns all the scalar values for this node.
func (r *LevelVersion) MapValues() mulbase.Mapper {
	var m = make(map[string]interface{}, 10)
	m["LevelVersion.version"] = r.Version
	m["LevelVersion.maxTime"] = r.MaxTime
	m["LevelVersion.minLevel"] = r.MinLevel
	m["LevelVersion.description"] = r.Description
	m["LevelVersion.gameMode"] = r.GameMode
	m["LevelVersion.song"] = r.Song
	m["LevelVersion.gravity"] = r.Gravity
	m["LevelVersion.items"] = r.Items
	m["LevelVersion.credits"] = r.Credits
	m["LevelVersion.created"] = r.Created
	if r.Uid != "" {
		m["uid"] = r.Uid
	}
	r.SetType()
	m["dgraph.type"] = r.Type
	return m
}

//LevelVersionScalars is simply to avoid a map[string]interface{}
//It is a mirror of the previous struct with all scalar values.
type LevelVersionScalars struct {
	mulbase.Node
	Version     int        `json:"LevelVersion.version,omitempty"`
	MaxTime     int        `json:"LevelVersion.maxTime,omitempty"`
	MinLevel    int        `json:"LevelVersion.minLevel,omitempty"`
	Description string     `json:"LevelVersion.description,omitempty"`
	GameMode    string     `json:"LevelVersion.gameMode,omitempty"`
	Song        int        `json:"LevelVersion.song,omitempty"`
	Gravity     float64    `json:"LevelVersion.gravity,omitempty"`
	Items       []Item     `json:"LevelVersion.items,omitempty"`
	Credits     string     `json:"LevelVersion.credits,omitempty"`
	Created     *time.Time `json:"LevelVersion.created,omitempty"`
}

func (s *LevelVersionScalars) Values() mulbase.DNode {
	return s
}

func (s *LevelVersionScalars) MapValues() mulbase.Mapper {
	panic("LevelVersionScalars called, use the original one instead")
}

func (s *LevelVersionScalars) Fields() mulbase.FieldList {
	return LevelVersionFields
}

//End of model.template
type PM struct {
	//This line declares basic properties for a database node.
	mulbase.Node
	//List of interfaces implemented.
	Message
	//Regular fields
	To *User `json:"PM.to,omitempty"`
}

var PMFields mulbase.FieldList = []mulbase.Field{MakeField("PM.to", 0|mulbase.MetaObject|mulbase.MetaReverse), MakeField("Message.from", 0|mulbase.MetaObject), MakeField("Message.content", 0), MakeField("Message.time", 0)}

//Generating constant field values.
const (
	PMToField      mulbase.Predicate = "PM.to"
	PMFromField    mulbase.Predicate = "Message.from"
	PMContentField mulbase.Predicate = "Message.content"
	PMTimeField    mulbase.Predicate = "Message.time"
)

//SaveValues saves the node values that
//do not contain any references to other objects.
func (r *PM) SaveValues(ctx context.Context, txn *mulbase.Txn) error {
	mut := mulbase.CreateMutation(r.Values(), mulbase.QuerySet)
	err := txn.Query(ctx, mut)
	return err
}
func (r *PM) GetType() []string {
	if r.Type == nil {
		r.SetType()
	}
	return r.Type
}

//Fields returns all Scalar fields for this value.
func (r *PM) Fields() mulbase.FieldList {
	return PMFields
}

//Sets the types. This DOES NOT include interfaces!
//as they are set in dgraph already.
func (r *PM) SetType() {
	r.Type = []string{
		"PM",
	}
}

//Values returns all the scalar values for this node.
func (r *PM) Values() mulbase.DNode {
	var m PMScalars
	m.Content = r.Content
	m.Time = r.Time
	r.SetType()
	m.Node = r.Node
	return &m
}

//Values returns all the scalar values for this node.
func (r *PM) MapValues() mulbase.Mapper {
	var m = make(map[string]interface{}, 2)
	m["Message.content"] = r.Content
	m["Message.time"] = r.Time
	if r.Uid != "" {
		m["uid"] = r.Uid
	}
	r.SetType()
	m["dgraph.type"] = r.Type
	return m
}

//PMScalars is simply to avoid a map[string]interface{}
//It is a mirror of the previous struct with all scalar values.
type PMScalars struct {
	mulbase.Node
	Content string     `json:"Message.content,omitempty"`
	Time    *time.Time `json:"Message.time,omitempty"`
}

func (s *PMScalars) Values() mulbase.DNode {
	return s
}

func (s *PMScalars) MapValues() mulbase.Mapper {
	panic("PMScalars called, use the original one instead")
}

func (s *PMScalars) Fields() mulbase.FieldList {
	return PMFields
}

//End of model.template
type ChatMessage struct {
	//This line declares basic properties for a database node.
	mulbase.Node
	//List of interfaces implemented.
	Message
	//Regular fields
	Room string `json:"ChatMessage.room,omitempty"`
}

var ChatMessageFields mulbase.FieldList = []mulbase.Field{MakeField("ChatMessage.room", 0), MakeField("Message.from", 0|mulbase.MetaObject), MakeField("Message.content", 0), MakeField("Message.time", 0)}

//Generating constant field values.
const (
	ChatMessageRoomField    mulbase.Predicate = "ChatMessage.room"
	ChatMessageFromField    mulbase.Predicate = "Message.from"
	ChatMessageContentField mulbase.Predicate = "Message.content"
	ChatMessageTimeField    mulbase.Predicate = "Message.time"
)

//SaveValues saves the node values that
//do not contain any references to other objects.
func (r *ChatMessage) SaveValues(ctx context.Context, txn *mulbase.Txn) error {
	mut := mulbase.CreateMutation(r.Values(), mulbase.QuerySet)
	err := txn.Query(ctx, mut)
	return err
}
func (r *ChatMessage) GetType() []string {
	if r.Type == nil {
		r.SetType()
	}
	return r.Type
}

//Fields returns all Scalar fields for this value.
func (r *ChatMessage) Fields() mulbase.FieldList {
	return ChatMessageFields
}

//Sets the types. This DOES NOT include interfaces!
//as they are set in dgraph already.
func (r *ChatMessage) SetType() {
	r.Type = []string{
		"ChatMessage",
	}
}

//Values returns all the scalar values for this node.
func (r *ChatMessage) Values() mulbase.DNode {
	var m ChatMessageScalars
	m.Room = r.Room
	m.Content = r.Content
	m.Time = r.Time
	r.SetType()
	m.Node = r.Node
	return &m
}

//Values returns all the scalar values for this node.
func (r *ChatMessage) MapValues() mulbase.Mapper {
	var m = make(map[string]interface{}, 3)
	m["ChatMessage.room"] = r.Room
	m["Message.content"] = r.Content
	m["Message.time"] = r.Time
	if r.Uid != "" {
		m["uid"] = r.Uid
	}
	r.SetType()
	m["dgraph.type"] = r.Type
	return m
}

//ChatMessageScalars is simply to avoid a map[string]interface{}
//It is a mirror of the previous struct with all scalar values.
type ChatMessageScalars struct {
	mulbase.Node
	Room    string     `json:"ChatMessage.room,omitempty"`
	Content string     `json:"Message.content,omitempty"`
	Time    *time.Time `json:"Message.time,omitempty"`
}

func (s *ChatMessageScalars) Values() mulbase.DNode {
	return s
}

func (s *ChatMessageScalars) MapValues() mulbase.Mapper {
	panic("ChatMessageScalars called, use the original one instead")
}

func (s *ChatMessageScalars) Fields() mulbase.FieldList {
	return ChatMessageFields
}

//End of model.template
type Page struct {
	//This line declares basic properties for a database node.
	mulbase.Node
	//Regular fields
	Levels     []PageLevel `json:"Page.levels,omitempty"`
	Identifier string      `json:"Page.identifier,omitempty"`
}

var PageFields mulbase.FieldList = []mulbase.Field{MakeField("Page.levels", 0|mulbase.MetaObject|mulbase.MetaList), MakeField("Page.identifier", 0)}

//Generating constant field values.
const (
	PageLevelsField     mulbase.Predicate = "Page.levels"
	PageIdentifierField mulbase.Predicate = "Page.identifier"
)

//SaveValues saves the node values that
//do not contain any references to other objects.
func (r *Page) SaveValues(ctx context.Context, txn *mulbase.Txn) error {
	mut := mulbase.CreateMutation(r.Values(), mulbase.QuerySet)
	err := txn.Query(ctx, mut)
	return err
}
func (r *Page) GetType() []string {
	if r.Type == nil {
		r.SetType()
	}
	return r.Type
}

//Fields returns all Scalar fields for this value.
func (r *Page) Fields() mulbase.FieldList {
	return PageFields
}

//Sets the types. This DOES NOT include interfaces!
//as they are set in dgraph already.
func (r *Page) SetType() {
	r.Type = []string{
		"Page",
	}
}

//Values returns all the scalar values for this node.
func (r *Page) Values() mulbase.DNode {
	var m PageScalars
	m.Identifier = r.Identifier
	r.SetType()
	m.Node = r.Node
	return &m
}

//Values returns all the scalar values for this node.
func (r *Page) MapValues() mulbase.Mapper {
	var m = make(map[string]interface{}, 1)
	m["Page.identifier"] = r.Identifier
	if r.Uid != "" {
		m["uid"] = r.Uid
	}
	r.SetType()
	m["dgraph.type"] = r.Type
	return m
}

//PageScalars is simply to avoid a map[string]interface{}
//It is a mirror of the previous struct with all scalar values.
type PageScalars struct {
	mulbase.Node
	Identifier string `json:"Page.identifier,omitempty"`
}

func (s *PageScalars) Values() mulbase.DNode {
	return s
}

func (s *PageScalars) MapValues() mulbase.Mapper {
	panic("PageScalars called, use the original one instead")
}

func (s *PageScalars) Fields() mulbase.FieldList {
	return PageFields
}

//End of model.template
type PageLevel struct {
	//This line declares basic properties for a database node.
	mulbase.Node
	//Regular fields
	Order int    `json:"PageLevel.order,omitempty"`
	Level *Level `json:"PageLevel.level,omitempty"`
}

var PageLevelFields mulbase.FieldList = []mulbase.Field{MakeField("PageLevel.order", 0), MakeField("PageLevel.level", 0|mulbase.MetaObject)}

//Generating constant field values.
const (
	PageLevelOrderField mulbase.Predicate = "PageLevel.order"
	PageLevelLevelField mulbase.Predicate = "PageLevel.level"
)

//SaveValues saves the node values that
//do not contain any references to other objects.
func (r *PageLevel) SaveValues(ctx context.Context, txn *mulbase.Txn) error {
	mut := mulbase.CreateMutation(r.Values(), mulbase.QuerySet)
	err := txn.Query(ctx, mut)
	return err
}
func (r *PageLevel) GetType() []string {
	if r.Type == nil {
		r.SetType()
	}
	return r.Type
}

//Fields returns all Scalar fields for this value.
func (r *PageLevel) Fields() mulbase.FieldList {
	return PageLevelFields
}

//Sets the types. This DOES NOT include interfaces!
//as they are set in dgraph already.
func (r *PageLevel) SetType() {
	r.Type = []string{
		"PageLevel",
	}
}

//Values returns all the scalar values for this node.
func (r *PageLevel) Values() mulbase.DNode {
	var m PageLevelScalars
	m.Order = r.Order
	r.SetType()
	m.Node = r.Node
	return &m
}

//Values returns all the scalar values for this node.
func (r *PageLevel) MapValues() mulbase.Mapper {
	var m = make(map[string]interface{}, 1)
	m["PageLevel.order"] = r.Order
	if r.Uid != "" {
		m["uid"] = r.Uid
	}
	r.SetType()
	m["dgraph.type"] = r.Type
	return m
}

//PageLevelScalars is simply to avoid a map[string]interface{}
//It is a mirror of the previous struct with all scalar values.
type PageLevelScalars struct {
	mulbase.Node
	Order int `json:"PageLevel.order,omitempty"`
}

func (s *PageLevelScalars) Values() mulbase.DNode {
	return s
}

func (s *PageLevelScalars) MapValues() mulbase.Mapper {
	panic("PageLevelScalars called, use the original one instead")
}

func (s *PageLevelScalars) Fields() mulbase.FieldList {
	return PageLevelFields
}

//End of model.template
type User struct {
	//This line declares basic properties for a database node.
	mulbase.Node
	//Regular fields
	Password     string     `json:"User.password,omitempty"`
	Name         string     `json:"User.name,omitempty"`
	Email        string     `json:"User.email,omitempty"`
	Registered   *time.Time `json:"User.registered,omitempty"`
	Active       bool       `json:"User.active,omitempty"`
	LastLogin    *time.Time `json:"User.lastLogin,omitempty"`
	Rank         int        `json:"User.rank,omitempty"`
	Exp          int        `json:"User.exp,omitempty"`
	Speed        int        `json:"User.speed,omitempty"`
	Jump         int        `json:"User.jump,omitempty"`
	Acceleration int        `json:"User.acceleration,omitempty"`
	Power        int        `json:"User.power,omitempty"`
	Hats         []Hat      `json:"User.hats,omitempty"`
	Heads        []Head     `json:"User.heads,omitempty"`
	Bodies       []Body     `json:"User.bodies,omitempty"`
	Feets        []Feet     `json:"User.feets,omitempty"`
	Hat          Hat        `json:"User.hat,omitempty"`
	Head         Head       `json:"User.head,omitempty"`
	Body         Body       `json:"User.body,omitempty"`
	Feet         Feet       `json:"User.feet,omitempty"`
	Levels       []Level    `json:"User.levels,omitempty"`
	HatColor     int        `json:"User.hatColor,omitempty"`
	HeadColor    int        `json:"User.headColor,omitempty"`
	BodyColor    int        `json:"User.bodyColor,omitempty"`
	FeetColor    int        `json:"User.feetColor,omitempty"`
	Ignored      []User     `json:"User.ignored,omitempty"`
	Friends      []User     `json:"User.friends,omitempty"`
	Messages     []PM       `json:"User.messages,omitempty"`
}

var _ = MakeField("User.password", 0)
var UserFields mulbase.FieldList = []mulbase.Field{MakeField("User.name", 0), MakeField("User.email", 0), MakeField("User.registered", 0), MakeField("User.active", 0), MakeField("User.lastLogin", 0), MakeField("User.rank", 0), MakeField("User.exp", 0), MakeField("User.speed", 0), MakeField("User.jump", 0), MakeField("User.acceleration", 0), MakeField("User.power", 0), MakeField("User.hats", 0|mulbase.MetaList), MakeField("User.heads", 0|mulbase.MetaList), MakeField("User.bodies", 0|mulbase.MetaList), MakeField("User.feets", 0|mulbase.MetaList), MakeField("User.hat", 0), MakeField("User.head", 0), MakeField("User.body", 0), MakeField("User.feet", 0), MakeField("User.levels", 0|mulbase.MetaObject|mulbase.MetaList|mulbase.MetaReverse), MakeField("User.hatColor", 0), MakeField("User.headColor", 0), MakeField("User.bodyColor", 0), MakeField("User.feetColor", 0), MakeField("User.ignored", 0|mulbase.MetaObject|mulbase.MetaList), MakeField("User.friends", 0|mulbase.MetaObject|mulbase.MetaList), MakeField("User.messages", 0|mulbase.MetaObject|mulbase.MetaList|mulbase.MetaReverse)}

//Generating constant field values.
const (
	UserPasswordField     mulbase.Predicate = "User.password"
	UserNameField         mulbase.Predicate = "User.name"
	UserEmailField        mulbase.Predicate = "User.email"
	UserRegisteredField   mulbase.Predicate = "User.registered"
	UserActiveField       mulbase.Predicate = "User.active"
	UserLastLoginField    mulbase.Predicate = "User.lastLogin"
	UserRankField         mulbase.Predicate = "User.rank"
	UserExpField          mulbase.Predicate = "User.exp"
	UserSpeedField        mulbase.Predicate = "User.speed"
	UserJumpField         mulbase.Predicate = "User.jump"
	UserAccelerationField mulbase.Predicate = "User.acceleration"
	UserPowerField        mulbase.Predicate = "User.power"
	UserHatsField         mulbase.Predicate = "User.hats"
	UserHeadsField        mulbase.Predicate = "User.heads"
	UserBodiesField       mulbase.Predicate = "User.bodies"
	UserFeetsField        mulbase.Predicate = "User.feets"
	UserHatField          mulbase.Predicate = "User.hat"
	UserHeadField         mulbase.Predicate = "User.head"
	UserBodyField         mulbase.Predicate = "User.body"
	UserFeetField         mulbase.Predicate = "User.feet"
	UserLevelsField       mulbase.Predicate = "User.levels"
	UserHatColorField     mulbase.Predicate = "User.hatColor"
	UserHeadColorField    mulbase.Predicate = "User.headColor"
	UserBodyColorField    mulbase.Predicate = "User.bodyColor"
	UserFeetColorField    mulbase.Predicate = "User.feetColor"
	UserIgnoredField      mulbase.Predicate = "User.ignored"
	UserFriendsField      mulbase.Predicate = "User.friends"
	UserMessagesField     mulbase.Predicate = "User.messages"
)

//SaveValues saves the node values that
//do not contain any references to other objects.
func (r *User) SaveValues(ctx context.Context, txn *mulbase.Txn) error {
	mut := mulbase.CreateMutation(r.Values(), mulbase.QuerySet)
	err := txn.Query(ctx, mut)
	return err
}
func (r *User) GetType() []string {
	if r.Type == nil {
		r.SetType()
	}
	return r.Type
}

//Fields returns all Scalar fields for this value.
func (r *User) Fields() mulbase.FieldList {
	return UserFields
}

//Sets the types. This DOES NOT include interfaces!
//as they are set in dgraph already.
func (r *User) SetType() {
	r.Type = []string{
		"User",
	}
}

//Values returns all the scalar values for this node.
func (r *User) Values() mulbase.DNode {
	var m UserScalars
	m.Active = r.Active
	m.Rank = r.Rank
	m.Exp = r.Exp
	m.Speed = r.Speed
	m.Jump = r.Jump
	m.Acceleration = r.Acceleration
	m.Power = r.Power
	m.Hats = r.Hats
	m.Heads = r.Heads
	m.Bodies = r.Bodies
	m.Feets = r.Feets
	m.Hat = r.Hat
	m.Head = r.Head
	m.Body = r.Body
	m.Feet = r.Feet
	m.HatColor = r.HatColor
	m.HeadColor = r.HeadColor
	m.BodyColor = r.BodyColor
	m.FeetColor = r.FeetColor
	r.SetType()
	m.Node = r.Node
	return &m
}

//Values returns all the scalar values for this node.
func (r *User) MapValues() mulbase.Mapper {
	var m = make(map[string]interface{}, 24)
	m["User.active"] = r.Active
	m["User.rank"] = r.Rank
	m["User.exp"] = r.Exp
	m["User.speed"] = r.Speed
	m["User.jump"] = r.Jump
	m["User.acceleration"] = r.Acceleration
	m["User.power"] = r.Power
	m["User.hats"] = r.Hats
	m["User.heads"] = r.Heads
	m["User.bodies"] = r.Bodies
	m["User.feets"] = r.Feets
	m["User.hat"] = r.Hat
	m["User.head"] = r.Head
	m["User.body"] = r.Body
	m["User.feet"] = r.Feet
	m["User.hatColor"] = r.HatColor
	m["User.headColor"] = r.HeadColor
	m["User.bodyColor"] = r.BodyColor
	m["User.feetColor"] = r.FeetColor
	if r.Uid != "" {
		m["uid"] = r.Uid
	}
	r.SetType()
	m["dgraph.type"] = r.Type
	return m
}

//UserScalars is simply to avoid a map[string]interface{}
//It is a mirror of the previous struct with all scalar values.
type UserScalars struct {
	mulbase.Node
	Password     string     `json:"User.password,omitempty"`
	Name         string     `json:"User.name,omitempty"`
	Email        string     `json:"User.email,omitempty"`
	Registered   *time.Time `json:"User.registered,omitempty"`
	Active       bool       `json:"User.active,omitempty"`
	LastLogin    *time.Time `json:"User.lastLogin,omitempty"`
	Rank         int        `json:"User.rank,omitempty"`
	Exp          int        `json:"User.exp,omitempty"`
	Speed        int        `json:"User.speed,omitempty"`
	Jump         int        `json:"User.jump,omitempty"`
	Acceleration int        `json:"User.acceleration,omitempty"`
	Power        int        `json:"User.power,omitempty"`
	Hats         []Hat      `json:"User.hats,omitempty"`
	Heads        []Head     `json:"User.heads,omitempty"`
	Bodies       []Body     `json:"User.bodies,omitempty"`
	Feets        []Feet     `json:"User.feets,omitempty"`
	Hat          Hat        `json:"User.hat,omitempty"`
	Head         Head       `json:"User.head,omitempty"`
	Body         Body       `json:"User.body,omitempty"`
	Feet         Feet       `json:"User.feet,omitempty"`
	HatColor     int        `json:"User.hatColor,omitempty"`
	HeadColor    int        `json:"User.headColor,omitempty"`
	BodyColor    int        `json:"User.bodyColor,omitempty"`
	FeetColor    int        `json:"User.feetColor,omitempty"`
}

func (s *UserScalars) Values() mulbase.DNode {
	return s
}

func (s *UserScalars) MapValues() mulbase.Mapper {
	panic("UserScalars called, use the original one instead")
}

func (s *UserScalars) Fields() mulbase.FieldList {
	return UserFields
}

//End of model.template
type Error struct {
	//This line declares basic properties for a database node.
	mulbase.Node
	//Regular fields
	Message   string     `json:"Error.message,omitempty"`
	ErrorType string     `json:"Error.errorType,omitempty"`
	Time      *time.Time `json:"Error.time,omitempty"`
}

var ErrorFields mulbase.FieldList = []mulbase.Field{MakeField("Error.message", 0), MakeField("Error.errorType", 0), MakeField("Error.time", 0)}

//Generating constant field values.
const (
	ErrorMessageField   mulbase.Predicate = "Error.message"
	ErrorErrorTypeField mulbase.Predicate = "Error.errorType"
	ErrorTimeField      mulbase.Predicate = "Error.time"
)

//SaveValues saves the node values that
//do not contain any references to other objects.
func (r *Error) SaveValues(ctx context.Context, txn *mulbase.Txn) error {
	mut := mulbase.CreateMutation(r.Values(), mulbase.QuerySet)
	err := txn.Query(ctx, mut)
	return err
}
func (r *Error) GetType() []string {
	if r.Type == nil {
		r.SetType()
	}
	return r.Type
}

//Fields returns all Scalar fields for this value.
func (r *Error) Fields() mulbase.FieldList {
	return ErrorFields
}

//Sets the types. This DOES NOT include interfaces!
//as they are set in dgraph already.
func (r *Error) SetType() {
	r.Type = []string{
		"Error",
	}
}

//Values returns all the scalar values for this node.
func (r *Error) Values() mulbase.DNode {
	var m ErrorScalars
	m.Message = r.Message
	m.ErrorType = r.ErrorType
	m.Time = r.Time
	r.SetType()
	m.Node = r.Node
	return &m
}

//Values returns all the scalar values for this node.
func (r *Error) MapValues() mulbase.Mapper {
	var m = make(map[string]interface{}, 3)
	m["Error.message"] = r.Message
	m["Error.errorType"] = r.ErrorType
	m["Error.time"] = r.Time
	if r.Uid != "" {
		m["uid"] = r.Uid
	}
	r.SetType()
	m["dgraph.type"] = r.Type
	return m
}

//ErrorScalars is simply to avoid a map[string]interface{}
//It is a mirror of the previous struct with all scalar values.
type ErrorScalars struct {
	mulbase.Node
	Message   string     `json:"Error.message,omitempty"`
	ErrorType string     `json:"Error.errorType,omitempty"`
	Time      *time.Time `json:"Error.time,omitempty"`
}

func (s *ErrorScalars) Values() mulbase.DNode {
	return s
}

func (s *ErrorScalars) MapValues() mulbase.Mapper {
	panic("ErrorScalars called, use the original one instead")
}

func (s *ErrorScalars) Fields() mulbase.FieldList {
	return ErrorFields
}

//End of model.template
