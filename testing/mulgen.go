package mulgen

// Code generated by mulgen. DO NOT EDIT (or feel free but it will be lost!).
import (
	"context"
	"github.com/Vliro/mulbase"
	"time"
)

//Created from a GraphQL interface.
type Message struct {
	//This line declares basic properties for a database node.
	mulbase.Node
	From    *User     `json:"Message.from"`
	Content string    `json:"Message.content"`
	Time    time.Time `json:"Message.time"`
}

var MessageFields mulbase.FieldList = []mulbase.Field{MakeField("Message.from", 0|mulbase.MetaObject), MakeField("Message.content", 0), MakeField("Message.time", 0)}

//Generating constant field values.
const (
	MessageFromField    = "Message.from"
	MessageContentField = "Message.content"
	MessageTimeField    = "Message.time"
)

//SaveValues saves the node values that
//do not contain any references to other objects.
func (r *Message) SaveValues(ctx context.Context, txn *mulbase.Txn) error {
	mut := mulbase.CreateMutation(r.Values(), mulbase.QuerySet)
	err := txn.Query(ctx, mut)
	return err
}

//Fields returns all Scalar fields for this value.
func (r *Message) Fields() mulbase.FieldList {
	return MessageFields
}

//Sets the types. This DOES NOT include interfaces!
//as they are set in dgraph already.
func (r *Message) SetType() {
	r.Type = []string{
		"Message",
	}
}

//Values returns all the scalar values for this node.
func (r *Message) Values() mulbase.DNode {
	var m MessageScalars
	m.Content = r.Content
	m.Time = r.Time
	m.Uid = r.Uid
	return &m
}

//Values returns all the scalar values for this node.
func (r *Message) MapValues(types bool) mulbase.Mapper {
	var m = make(map[string]interface{}, 2)
	m["Message.content"] = r.Content
	m["Message.time"] = r.Time
	m["uid"] = r.Uid
	if types {
		r.SetType()
		m["dgraph.type"] = r.Type
	}
	return m
}

//MessageScalars is simply to avoid a map[string]interface{}
//It is a mirror of the previous struct with all scalar values.
type MessageScalars struct {
	mulbase.Node
	Content string    `json:"Message.content"`
	Time    time.Time `json:"Message.time"`
}

func (s *MessageScalars) Values() mulbase.DNode {
	return s
}

func (s *MessageScalars) MapValues(types bool) mulbase.Mapper {
	panic("MessageScalars called, use the original one instead")
}

func (s *MessageScalars) Fields() mulbase.FieldList {
	return MessageFields
}

//End of model.template
type Level struct {
	//This line declares basic properties for a database node.
	mulbase.Node
	//Regular fields
	Name      string         `json:"Level.name"`
	Password  string         `json:"Level.password"`
	Hash      string         `json:"Level.hash"`
	Size      int            `json:"Level.size"`
	Updated   time.Time      `json:"Level.updated"`
	PlayCount int            `json:"Level.playCount"`
	Live      bool           `json:"Level.live"`
	Rating    float64        `json:"Level.rating"`
	Owner     *User          `json:"Level.owner"`
	Version   *LevelVersion  `json:"Level.version"`
	Versions  []LevelVersion `json:"Level.versions"`
}

var LevelFields mulbase.FieldList = []mulbase.Field{MakeField("Level.name", 0), MakeField("Level.password", 0), MakeField("Level.hash", 0), MakeField("Level.size", 0), MakeField("Level.updated", 0), MakeField("Level.playCount", 0), MakeField("Level.live", 0), MakeField("Level.rating", 0), MakeField("Level.owner", 0|mulbase.MetaObject|mulbase.MetaReverse), MakeField("Level.version", 0|mulbase.MetaObject), MakeField("Level.versions", 0|mulbase.MetaObject|mulbase.MetaList)}

//Generating constant field values.
const (
	LevelNameField      = "Level.name"
	LevelPasswordField  = "Level.password"
	LevelHashField      = "Level.hash"
	LevelSizeField      = "Level.size"
	LevelUpdatedField   = "Level.updated"
	LevelPlayCountField = "Level.playCount"
	LevelLiveField      = "Level.live"
	LevelRatingField    = "Level.rating"
	LevelOwnerField     = "Level.owner"
	LevelVersionField   = "Level.version"
	LevelVersionsField  = "Level.versions"
)

//SaveValues saves the node values that
//do not contain any references to other objects.
func (r *Level) SaveValues(ctx context.Context, txn *mulbase.Txn) error {
	mut := mulbase.CreateMutation(r.Values(), mulbase.QuerySet)
	err := txn.Query(ctx, mut)
	return err
}

//Fields returns all Scalar fields for this value.
func (r *Level) Fields() mulbase.FieldList {
	return LevelFields
}

//Sets the types. This DOES NOT include interfaces!
//as they are set in dgraph already.
func (r *Level) SetType() {
	r.Type = []string{
		"Level",
	}
}

//Values returns all the scalar values for this node.
func (r *Level) Values() mulbase.DNode {
	var m LevelScalars
	m.Name = r.Name
	m.Password = r.Password
	m.Hash = r.Hash
	m.Size = r.Size
	m.PlayCount = r.PlayCount
	m.Live = r.Live
	m.Rating = r.Rating
	m.Uid = r.Uid
	return &m
}

//Values returns all the scalar values for this node.
func (r *Level) MapValues(types bool) mulbase.Mapper {
	var m = make(map[string]interface{}, 7)
	m["Level.name"] = r.Name
	m["Level.password"] = r.Password
	m["Level.hash"] = r.Hash
	m["Level.size"] = r.Size
	m["Level.playCount"] = r.PlayCount
	m["Level.live"] = r.Live
	m["Level.rating"] = r.Rating
	m["uid"] = r.Uid
	if types {
		r.SetType()
		m["dgraph.type"] = r.Type
	}
	return m
}

//LevelScalars is simply to avoid a map[string]interface{}
//It is a mirror of the previous struct with all scalar values.
type LevelScalars struct {
	mulbase.Node
	Name      string  `json:"Level.name"`
	Password  string  `json:"Level.password"`
	Hash      string  `json:"Level.hash"`
	Size      int     `json:"Level.size"`
	PlayCount int     `json:"Level.playCount"`
	Live      bool    `json:"Level.live"`
	Rating    float64 `json:"Level.rating"`
}

func (s *LevelScalars) Values() mulbase.DNode {
	return s
}

func (s *LevelScalars) MapValues(types bool) mulbase.Mapper {
	panic("LevelScalars called, use the original one instead")
}

func (s *LevelScalars) Fields() mulbase.FieldList {
	return LevelFields
}

//End of model.template
type LevelVersion struct {
	//This line declares basic properties for a database node.
	mulbase.Node
	//Regular fields
	Version     int       `json:"LevelVersion.version"`
	MaxTime     int       `json:"LevelVersion.maxTime"`
	MinLevel    int       `json:"LevelVersion.minLevel"`
	Description string    `json:"LevelVersion.description"`
	GameMode    string    `json:"LevelVersion.gameMode"`
	Song        int       `json:"LevelVersion.song"`
	Gravity     float64   `json:"LevelVersion.gravity"`
	Items       []Item    `json:"LevelVersion.items"`
	Credits     string    `json:"LevelVersion.credits"`
	Created     time.Time `json:"LevelVersion.created"`
}

var LevelVersionFields mulbase.FieldList = []mulbase.Field{MakeField("LevelVersion.version", 0), MakeField("LevelVersion.maxTime", 0), MakeField("LevelVersion.minLevel", 0), MakeField("LevelVersion.description", 0), MakeField("LevelVersion.gameMode", 0), MakeField("LevelVersion.song", 0), MakeField("LevelVersion.gravity", 0), MakeField("LevelVersion.items", 0|mulbase.MetaList), MakeField("LevelVersion.credits", 0), MakeField("LevelVersion.created", 0)}

//Generating constant field values.
const (
	LevelVersionVersionField     = "LevelVersion.version"
	LevelVersionMaxTimeField     = "LevelVersion.maxTime"
	LevelVersionMinLevelField    = "LevelVersion.minLevel"
	LevelVersionDescriptionField = "LevelVersion.description"
	LevelVersionGameModeField    = "LevelVersion.gameMode"
	LevelVersionSongField        = "LevelVersion.song"
	LevelVersionGravityField     = "LevelVersion.gravity"
	LevelVersionItemsField       = "LevelVersion.items"
	LevelVersionCreditsField     = "LevelVersion.credits"
	LevelVersionCreatedField     = "LevelVersion.created"
)

//SaveValues saves the node values that
//do not contain any references to other objects.
func (r *LevelVersion) SaveValues(ctx context.Context, txn *mulbase.Txn) error {
	mut := mulbase.CreateMutation(r.Values(), mulbase.QuerySet)
	err := txn.Query(ctx, mut)
	return err
}

//Fields returns all Scalar fields for this value.
func (r *LevelVersion) Fields() mulbase.FieldList {
	return LevelVersionFields
}

//Sets the types. This DOES NOT include interfaces!
//as they are set in dgraph already.
func (r *LevelVersion) SetType() {
	r.Type = []string{
		"LevelVersion",
	}
}

//Values returns all the scalar values for this node.
func (r *LevelVersion) Values() mulbase.DNode {
	var m LevelVersionScalars
	m.Version = r.Version
	m.MaxTime = r.MaxTime
	m.MinLevel = r.MinLevel
	m.Description = r.Description
	m.GameMode = r.GameMode
	m.Song = r.Song
	m.Gravity = r.Gravity
	m.Credits = r.Credits
	m.Created = r.Created
	m.Uid = r.Uid
	return &m
}

//Values returns all the scalar values for this node.
func (r *LevelVersion) MapValues(types bool) mulbase.Mapper {
	var m = make(map[string]interface{}, 9)
	m["LevelVersion.version"] = r.Version
	m["LevelVersion.maxTime"] = r.MaxTime
	m["LevelVersion.minLevel"] = r.MinLevel
	m["LevelVersion.description"] = r.Description
	m["LevelVersion.gameMode"] = r.GameMode
	m["LevelVersion.song"] = r.Song
	m["LevelVersion.gravity"] = r.Gravity
	m["LevelVersion.credits"] = r.Credits
	m["LevelVersion.created"] = r.Created
	m["uid"] = r.Uid
	if types {
		r.SetType()
		m["dgraph.type"] = r.Type
	}
	return m
}

//LevelVersionScalars is simply to avoid a map[string]interface{}
//It is a mirror of the previous struct with all scalar values.
type LevelVersionScalars struct {
	mulbase.Node
	Version     int       `json:"LevelVersion.version"`
	MaxTime     int       `json:"LevelVersion.maxTime"`
	MinLevel    int       `json:"LevelVersion.minLevel"`
	Description string    `json:"LevelVersion.description"`
	GameMode    string    `json:"LevelVersion.gameMode"`
	Song        int       `json:"LevelVersion.song"`
	Gravity     float64   `json:"LevelVersion.gravity"`
	Credits     string    `json:"LevelVersion.credits"`
	Created     time.Time `json:"LevelVersion.created"`
}

func (s *LevelVersionScalars) Values() mulbase.DNode {
	return s
}

func (s *LevelVersionScalars) MapValues(types bool) mulbase.Mapper {
	panic("LevelVersionScalars called, use the original one instead")
}

func (s *LevelVersionScalars) Fields() mulbase.FieldList {
	return LevelVersionFields
}

//End of model.template
type PM struct {
	//This line declares basic properties for a database node.
	mulbase.Node
	//List of interfaces implemented.
	Message
	//Regular fields
	To *User `json:"PM.to"`
}

var PMFields mulbase.FieldList = []mulbase.Field{MakeField("PM.to", 0|mulbase.MetaObject), MakeField("Message.from", 0|mulbase.MetaObject), MakeField("Message.content", 0), MakeField("Message.time", 0)}

//Generating constant field values.
const (
	PMToField      = "PM.to"
	PMFromField    = "Message.from"
	PMContentField = "Message.content"
	PMTimeField    = "Message.time"
)

//SaveValues saves the node values that
//do not contain any references to other objects.
func (r *PM) SaveValues(ctx context.Context, txn *mulbase.Txn) error {
	mut := mulbase.CreateMutation(r.Values(), mulbase.QuerySet)
	err := txn.Query(ctx, mut)
	return err
}

//Fields returns all Scalar fields for this value.
func (r *PM) Fields() mulbase.FieldList {
	return PMFields
}

//Sets the types. This DOES NOT include interfaces!
//as they are set in dgraph already.
func (r *PM) SetType() {
	r.Type = []string{
		"PM",
	}
}

//Values returns all the scalar values for this node.
func (r *PM) Values() mulbase.DNode {
	var m PMScalars
	m.Content = r.Content
	m.Time = r.Time
	m.Uid = r.Uid
	return &m
}

//Values returns all the scalar values for this node.
func (r *PM) MapValues(types bool) mulbase.Mapper {
	var m = make(map[string]interface{}, 2)
	m["Message.content"] = r.Content
	m["Message.time"] = r.Time
	m["uid"] = r.Uid
	if types {
		r.SetType()
		m["dgraph.type"] = r.Type
	}
	return m
}

//PMScalars is simply to avoid a map[string]interface{}
//It is a mirror of the previous struct with all scalar values.
type PMScalars struct {
	mulbase.Node
	Content string    `json:"Message.content"`
	Time    time.Time `json:"Message.time"`
}

func (s *PMScalars) Values() mulbase.DNode {
	return s
}

func (s *PMScalars) MapValues(types bool) mulbase.Mapper {
	panic("PMScalars called, use the original one instead")
}

func (s *PMScalars) Fields() mulbase.FieldList {
	return PMFields
}

//End of model.template
type ChatMessage struct {
	//This line declares basic properties for a database node.
	mulbase.Node
	//List of interfaces implemented.
	Message
	//Regular fields
	Room string `json:"ChatMessage.room"`
}

var ChatMessageFields mulbase.FieldList = []mulbase.Field{MakeField("ChatMessage.room", 0), MakeField("Message.from", 0|mulbase.MetaObject), MakeField("Message.content", 0), MakeField("Message.time", 0)}

//Generating constant field values.
const (
	ChatMessageRoomField    = "ChatMessage.room"
	ChatMessageFromField    = "Message.from"
	ChatMessageContentField = "Message.content"
	ChatMessageTimeField    = "Message.time"
)

//SaveValues saves the node values that
//do not contain any references to other objects.
func (r *ChatMessage) SaveValues(ctx context.Context, txn *mulbase.Txn) error {
	mut := mulbase.CreateMutation(r.Values(), mulbase.QuerySet)
	err := txn.Query(ctx, mut)
	return err
}

//Fields returns all Scalar fields for this value.
func (r *ChatMessage) Fields() mulbase.FieldList {
	return ChatMessageFields
}

//Sets the types. This DOES NOT include interfaces!
//as they are set in dgraph already.
func (r *ChatMessage) SetType() {
	r.Type = []string{
		"ChatMessage",
	}
}

//Values returns all the scalar values for this node.
func (r *ChatMessage) Values() mulbase.DNode {
	var m ChatMessageScalars
	m.Room = r.Room
	m.Content = r.Content
	m.Time = r.Time
	m.Uid = r.Uid
	return &m
}

//Values returns all the scalar values for this node.
func (r *ChatMessage) MapValues(types bool) mulbase.Mapper {
	var m = make(map[string]interface{}, 3)
	m["ChatMessage.room"] = r.Room
	m["Message.content"] = r.Content
	m["Message.time"] = r.Time
	m["uid"] = r.Uid
	if types {
		r.SetType()
		m["dgraph.type"] = r.Type
	}
	return m
}

//ChatMessageScalars is simply to avoid a map[string]interface{}
//It is a mirror of the previous struct with all scalar values.
type ChatMessageScalars struct {
	mulbase.Node
	Room    string    `json:"ChatMessage.room"`
	Content string    `json:"Message.content"`
	Time    time.Time `json:"Message.time"`
}

func (s *ChatMessageScalars) Values() mulbase.DNode {
	return s
}

func (s *ChatMessageScalars) MapValues(types bool) mulbase.Mapper {
	panic("ChatMessageScalars called, use the original one instead")
}

func (s *ChatMessageScalars) Fields() mulbase.FieldList {
	return ChatMessageFields
}

//End of model.template
type Page struct {
	//This line declares basic properties for a database node.
	mulbase.Node
	//Regular fields
	Levels     []PageLevel `json:"Page.levels"`
	Identifier string      `json:"Page.identifier"`
}

var PageFields mulbase.FieldList = []mulbase.Field{MakeField("Page.levels", 0|mulbase.MetaObject|mulbase.MetaList), MakeField("Page.identifier", 0)}

//Generating constant field values.
const (
	PageLevelsField     = "Page.levels"
	PageIdentifierField = "Page.identifier"
)

//SaveValues saves the node values that
//do not contain any references to other objects.
func (r *Page) SaveValues(ctx context.Context, txn *mulbase.Txn) error {
	mut := mulbase.CreateMutation(r.Values(), mulbase.QuerySet)
	err := txn.Query(ctx, mut)
	return err
}

//Fields returns all Scalar fields for this value.
func (r *Page) Fields() mulbase.FieldList {
	return PageFields
}

//Sets the types. This DOES NOT include interfaces!
//as they are set in dgraph already.
func (r *Page) SetType() {
	r.Type = []string{
		"Page",
	}
}

//Values returns all the scalar values for this node.
func (r *Page) Values() mulbase.DNode {
	var m PageScalars
	m.Identifier = r.Identifier
	m.Uid = r.Uid
	return &m
}

//Values returns all the scalar values for this node.
func (r *Page) MapValues(types bool) mulbase.Mapper {
	var m = make(map[string]interface{}, 1)
	m["Page.identifier"] = r.Identifier
	m["uid"] = r.Uid
	if types {
		r.SetType()
		m["dgraph.type"] = r.Type
	}
	return m
}

//PageScalars is simply to avoid a map[string]interface{}
//It is a mirror of the previous struct with all scalar values.
type PageScalars struct {
	mulbase.Node
	Identifier string `json:"Page.identifier"`
}

func (s *PageScalars) Values() mulbase.DNode {
	return s
}

func (s *PageScalars) MapValues(types bool) mulbase.Mapper {
	panic("PageScalars called, use the original one instead")
}

func (s *PageScalars) Fields() mulbase.FieldList {
	return PageFields
}

//End of model.template
type PageLevel struct {
	//This line declares basic properties for a database node.
	mulbase.Node
	//Regular fields
	Order int    `json:"PageLevel.order"`
	Level *Level `json:"PageLevel.level"`
}

var PageLevelFields mulbase.FieldList = []mulbase.Field{MakeField("PageLevel.order", 0), MakeField("PageLevel.level", 0|mulbase.MetaObject)}

//Generating constant field values.
const (
	PageLevelOrderField = "PageLevel.order"
	PageLevelLevelField = "PageLevel.level"
)

//SaveValues saves the node values that
//do not contain any references to other objects.
func (r *PageLevel) SaveValues(ctx context.Context, txn *mulbase.Txn) error {
	mut := mulbase.CreateMutation(r.Values(), mulbase.QuerySet)
	err := txn.Query(ctx, mut)
	return err
}

//Fields returns all Scalar fields for this value.
func (r *PageLevel) Fields() mulbase.FieldList {
	return PageLevelFields
}

//Sets the types. This DOES NOT include interfaces!
//as they are set in dgraph already.
func (r *PageLevel) SetType() {
	r.Type = []string{
		"PageLevel",
	}
}

//Values returns all the scalar values for this node.
func (r *PageLevel) Values() mulbase.DNode {
	var m PageLevelScalars
	m.Order = r.Order
	m.Uid = r.Uid
	return &m
}

//Values returns all the scalar values for this node.
func (r *PageLevel) MapValues(types bool) mulbase.Mapper {
	var m = make(map[string]interface{}, 1)
	m["PageLevel.order"] = r.Order
	m["uid"] = r.Uid
	if types {
		r.SetType()
		m["dgraph.type"] = r.Type
	}
	return m
}

//PageLevelScalars is simply to avoid a map[string]interface{}
//It is a mirror of the previous struct with all scalar values.
type PageLevelScalars struct {
	mulbase.Node
	Order int `json:"PageLevel.order"`
}

func (s *PageLevelScalars) Values() mulbase.DNode {
	return s
}

func (s *PageLevelScalars) MapValues(types bool) mulbase.Mapper {
	panic("PageLevelScalars called, use the original one instead")
}

func (s *PageLevelScalars) Fields() mulbase.FieldList {
	return PageLevelFields
}

//End of model.template
type User struct {
	//This line declares basic properties for a database node.
	mulbase.Node
	//Regular fields
	Password     string    `json:"User.password,omitempty"`
	Name         string    `json:"User.name"`
	Email        string    `json:"User.email"`
	Registered   time.Time `json:"User.registered"`
	Active       bool      `json:"User.active"`
	LastLogin    time.Time `json:"User.lastLogin"`
	Rank         int       `json:"User.rank"`
	Exp          int       `json:"User.exp"`
	Speed        int       `json:"User.speed"`
	Jump         int       `json:"User.jump"`
	Acceleration int       `json:"User.acceleration"`
	Power        int       `json:"User.power"`
	Hats         []Hat     `json:"User.hats"`
	Heads        []Head    `json:"User.heads"`
	Bodies       []Body    `json:"User.bodies"`
	Feets        []Feet    `json:"User.feets"`
	Hat          Hat       `json:"User.hat"`
	Head         Head      `json:"User.head"`
	Body         Body      `json:"User.body"`
	Feet         Feet      `json:"User.feet"`
	Levels       []Level   `json:"~Level.owner"`
	HatColor     int       `json:"User.hatColor"`
	HeadColor    int       `json:"User.headColor"`
	BodyColor    int       `json:"User.bodyColor"`
	FeetColor    int       `json:"User.feetColor"`
	Ignored      []User    `json:"User.ignored"`
	Friends      []User    `json:"User.friends"`
	Messages     []PM      `json:"User.messages"`
}

var _ = MakeField("User.password", 0)
var UserFields mulbase.FieldList = []mulbase.Field{MakeField("User.name", 0), MakeField("User.email", 0), MakeField("User.registered", 0), MakeField("User.active", 0), MakeField("User.lastLogin", 0), MakeField("User.rank", 0), MakeField("User.exp", 0), MakeField("User.speed", 0), MakeField("User.jump", 0), MakeField("User.acceleration", 0), MakeField("User.power", 0), MakeField("User.hats", 0|mulbase.MetaList), MakeField("User.heads", 0|mulbase.MetaList), MakeField("User.bodies", 0|mulbase.MetaList), MakeField("User.feets", 0|mulbase.MetaList), MakeField("User.hat", 0), MakeField("User.head", 0), MakeField("User.body", 0), MakeField("User.feet", 0), MakeField("~Level.owner", 0|mulbase.MetaObject|mulbase.MetaList|mulbase.MetaReverse), MakeField("User.hatColor", 0), MakeField("User.headColor", 0), MakeField("User.bodyColor", 0), MakeField("User.feetColor", 0), MakeField("User.ignored", 0|mulbase.MetaObject|mulbase.MetaList), MakeField("User.friends", 0|mulbase.MetaObject|mulbase.MetaList), MakeField("User.messages", 0|mulbase.MetaObject|mulbase.MetaList)}

//Generating constant field values.
const (
	UserPasswordField     = "User.password"
	UserNameField         = "User.name"
	UserEmailField        = "User.email"
	UserRegisteredField   = "User.registered"
	UserActiveField       = "User.active"
	UserLastLoginField    = "User.lastLogin"
	UserRankField         = "User.rank"
	UserExpField          = "User.exp"
	UserSpeedField        = "User.speed"
	UserJumpField         = "User.jump"
	UserAccelerationField = "User.acceleration"
	UserPowerField        = "User.power"
	UserHatsField         = "User.hats"
	UserHeadsField        = "User.heads"
	UserBodiesField       = "User.bodies"
	UserFeetsField        = "User.feets"
	UserHatField          = "User.hat"
	UserHeadField         = "User.head"
	UserBodyField         = "User.body"
	UserFeetField         = "User.feet"
	UserLevelsField       = "~Level.owner"
	UserHatColorField     = "User.hatColor"
	UserHeadColorField    = "User.headColor"
	UserBodyColorField    = "User.bodyColor"
	UserFeetColorField    = "User.feetColor"
	UserIgnoredField      = "User.ignored"
	UserFriendsField      = "User.friends"
	UserMessagesField     = "User.messages"
)

//SaveValues saves the node values that
//do not contain any references to other objects.
func (r *User) SaveValues(ctx context.Context, txn *mulbase.Txn) error {
	mut := mulbase.CreateMutation(r.Values(), mulbase.QuerySet)
	err := txn.Query(ctx, mut)
	return err
}

//Fields returns all Scalar fields for this value.
func (r *User) Fields() mulbase.FieldList {
	return UserFields
}

//Sets the types. This DOES NOT include interfaces!
//as they are set in dgraph already.
func (r *User) SetType() {
	r.Type = []string{
		"User",
	}
}

//Values returns all the scalar values for this node.
func (r *User) Values() mulbase.DNode {
	var m UserScalars
	m.Name = r.Name
	m.Email = r.Email
	m.Registered = r.Registered
	m.Active = r.Active
	m.LastLogin = r.LastLogin
	m.Rank = r.Rank
	m.Exp = r.Exp
	m.Speed = r.Speed
	m.Jump = r.Jump
	m.Acceleration = r.Acceleration
	m.Power = r.Power
	m.HatColor = r.HatColor
	m.HeadColor = r.HeadColor
	m.BodyColor = r.BodyColor
	m.FeetColor = r.FeetColor
	m.Uid = r.Uid
	return &m
}

//Values returns all the scalar values for this node.
func (r *User) MapValues(types bool) mulbase.Mapper {
	var m = make(map[string]interface{}, 16)
	m["User.name"] = r.Name
	m["User.email"] = r.Email
	m["User.registered"] = r.Registered
	m["User.active"] = r.Active
	m["User.lastLogin"] = r.LastLogin
	m["User.rank"] = r.Rank
	m["User.exp"] = r.Exp
	m["User.speed"] = r.Speed
	m["User.jump"] = r.Jump
	m["User.acceleration"] = r.Acceleration
	m["User.power"] = r.Power
	m["User.hatColor"] = r.HatColor
	m["User.headColor"] = r.HeadColor
	m["User.bodyColor"] = r.BodyColor
	m["User.feetColor"] = r.FeetColor
	m["uid"] = r.Uid
	if types {
		r.SetType()
		m["dgraph.type"] = r.Type
	}
	return m
}

//UserScalars is simply to avoid a map[string]interface{}
//It is a mirror of the previous struct with all scalar values.
type UserScalars struct {
	mulbase.Node
	Password     string    `json:"User.password,omitempty"`
	Name         string    `json:"User.name"`
	Email        string    `json:"User.email"`
	Registered   time.Time `json:"User.registered"`
	Active       bool      `json:"User.active"`
	LastLogin    time.Time `json:"User.lastLogin"`
	Rank         int       `json:"User.rank"`
	Exp          int       `json:"User.exp"`
	Speed        int       `json:"User.speed"`
	Jump         int       `json:"User.jump"`
	Acceleration int       `json:"User.acceleration"`
	Power        int       `json:"User.power"`
	HatColor     int       `json:"User.hatColor"`
	HeadColor    int       `json:"User.headColor"`
	BodyColor    int       `json:"User.bodyColor"`
	FeetColor    int       `json:"User.feetColor"`
}

func (s *UserScalars) Values() mulbase.DNode {
	return s
}

func (s *UserScalars) MapValues(types bool) mulbase.Mapper {
	panic("UserScalars called, use the original one instead")
}

func (s *UserScalars) Fields() mulbase.FieldList {
	return UserFields
}

//End of model.template
type Error struct {
	//This line declares basic properties for a database node.
	mulbase.Node
	//Regular fields
	Message   string    `json:"Error.message"`
	ErrorType string    `json:"Error.errorType"`
	Time      time.Time `json:"Error.time"`
}

var ErrorFields mulbase.FieldList = []mulbase.Field{MakeField("Error.message", 0), MakeField("Error.errorType", 0), MakeField("Error.time", 0)}

//Generating constant field values.
const (
	ErrorMessageField   = "Error.message"
	ErrorErrorTypeField = "Error.errorType"
	ErrorTimeField      = "Error.time"
)

//SaveValues saves the node values that
//do not contain any references to other objects.
func (r *Error) SaveValues(ctx context.Context, txn *mulbase.Txn) error {
	mut := mulbase.CreateMutation(r.Values(), mulbase.QuerySet)
	err := txn.Query(ctx, mut)
	return err
}

//Fields returns all Scalar fields for this value.
func (r *Error) Fields() mulbase.FieldList {
	return ErrorFields
}

//Sets the types. This DOES NOT include interfaces!
//as they are set in dgraph already.
func (r *Error) SetType() {
	r.Type = []string{
		"Error",
	}
}

//Values returns all the scalar values for this node.
func (r *Error) Values() mulbase.DNode {
	var m ErrorScalars
	m.Message = r.Message
	m.ErrorType = r.ErrorType
	m.Time = r.Time
	m.Uid = r.Uid
	return &m
}

//Values returns all the scalar values for this node.
func (r *Error) MapValues(types bool) mulbase.Mapper {
	var m = make(map[string]interface{}, 3)
	m["Error.message"] = r.Message
	m["Error.errorType"] = r.ErrorType
	m["Error.time"] = r.Time
	m["uid"] = r.Uid
	if types {
		r.SetType()
		m["dgraph.type"] = r.Type
	}
	return m
}

//ErrorScalars is simply to avoid a map[string]interface{}
//It is a mirror of the previous struct with all scalar values.
type ErrorScalars struct {
	mulbase.Node
	Message   string    `json:"Error.message"`
	ErrorType string    `json:"Error.errorType"`
	Time      time.Time `json:"Error.time"`
}

func (s *ErrorScalars) Values() mulbase.DNode {
	return s
}

func (s *ErrorScalars) MapValues(types bool) mulbase.Mapper {
	panic("ErrorScalars called, use the original one instead")
}

func (s *ErrorScalars) Fields() mulbase.FieldList {
	return ErrorFields
}

//End of model.template
